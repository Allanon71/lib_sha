/* Original Source Code by Egor-Skriptunoff
   Source Code : https://github.com/Egor-Skriptunoff/pure_lua_SHA
   MIT License
   ------------------------------------------------
   Ported to Hollywood by Fabio Falcucci
   Completed : 03/11/2021
   Version   : 1.0
   Contact   : info@a-mc.biz
   Patreon   : https://www.patreon.com/Allanon71
   GitHub    : https://github.com/Allanon71
   Twitter   : https://twitter.com/Allanon71
   Dependancies      : - none -
   Hollywood version : ported and tested with Hollywood 9.0
   ------------------------------------------------
   NOTES
   Debugging was a hell mostly because LUA table indexes starts from 0 while
   in Hollywood they starts from 1, in most cases I've added a dummy entry on index 0.
   Also there was problems handling the \0 character.
   
   See function test_hash_lib() for examples.
   Uncomment last line to perform a global test.
   
   All sha and hmac functions are stored in the sha table as follow:
     sha
       .md5           supported natively by Hollywood but ported as an exercise
       .sha1
       .sha224
       .sha256
       .sha512_224
       .sha512_256
       .sha384
       .sha512
       .sha3_224
       .sha3_256
       .sha3_384
       .sha3_512
       .shake128
       .shake256
       .hmac
       .hex2bin
       .base642bin
       .bin2base64
*/

Local sha_debug =  False; set to true to view some messages about your system's abilities and implementation branch chosen for your system

; Remap some functions to simulate the LUA behaviours
Local unpack       = Unpack
Local table_concat = Function(tbl, sep, i, j)
                       If IsNil(sep) Then sep = ""
                       If IsNil(i)   Then i = 1
                       If IsNil(j)   Then j = ListItems(tbl)-1
                       Local r = ""
                       For Local idx = i To j
                         r = r .. tbl[idx]
                         If idx < j Then r = r .. sep
                       Next

                       Return(r)
                     EndFunction
Local byte         = Function(s, i, j)
                       If IsNil(i)   Then i = 1
                       If IsNil(j)   Then j = i
                       Local v, k = {}, 1
                       For Local k = i To j             
                         v[k-i] = ByteAsc(s, k-1)
                       Next
                       Return(v)
                     EndFunction
Local char         = Function(...)
                       Local n = arg.n
                       Local v = ""
                       For Local i = 0 To n-1
                         v = v .. ByteChr(arg[i])
                       Next
                       Return(v)
                     EndFunction
Local string_rep   = RepeatStr
Local sub          = Function(t, s, e)
                       ; This one is hacked, very hacked but seems to work
                       Local l = ByteLen(t)
                       If e = 0 And Not(IsNil(e)) Then Return("")
                       
                       If IsNil(s)
                         s = 0
                       Else
                         s = s - 1
                       EndIf
                      
                       If IsNil(e) Or e = -1
                         e = l - 1
                       Else
                         e = e - 1
                       EndIf
                      
                       If s < 0
                         s = l + s + 1
                       EndIf

                       If e < 0
                         e = l + e + 1
                       EndIf
                       
                       Return(MidStr(t, s, e-s+1, #ENCODING_ISO8859_1))
                      
                     EndFunction
Local gsub         = PatternReplaceStr
Local gmatch       = PatternFindStr
Local string_format= FormatStr
Local floor        = Floor
Local ceil         = Ceil
Local math_min     = Min
Local math_max     = Max
Local tonumber     = ToNumber
Local type         = Function(v)
                       Switch GetType(v)
                         Case #STRING
                           Return("string")
                         Case #NUMBER
                           Return("number")
                         Case #TABLE
                           Return("table")
                         Case #FUNCTION
                           Return("function")
                         Case #USERDATA
                           Return("userdata")
                         Default
                           DebugPrint("UNKNOWN TYPE")
                       EndSwitch
                     EndFunction
                     
Local _MOD = Function(a, b)
               Local r = a % b
               If r<0 Then r = r + b ; Because of Lua mod act this way
               Return(r)
             EndFunction

; ---------------------------------------------------
Local Function get_precision(one)
   ;-- "one" must be either float 1.0 or integer 1
   ;-- returns bits_precision, is_integer
   ;-- This function works correctly with all floating point datatypes (including non-IEEE-754)
   Local k, n, m, prev_n = 0, one, one
   While True
      ; k, prev_n, n, m = k + 1, n, n + n + 1, m + m + k % 2
      k, prev_n, n, m = k + 1, n, n + n + 1, m + m + _MOD(k, 2)
      If k > 256 Or n - (n - 1) <> 1 Or m - (m - 1) <> 1 Or n = m
         Return(k, False)   ;-- floating point datatype
      ElseIf n = prev_n
         Return(k, True)    ;-- integer datatype
      EndIf
   Wend
   
   ; TESTED with 1 and 1.0
   ; Result OK
   ; 
   ; bits_precision = 53
   ; is_integer     = False
EndFunction
; ---------------------------------------------------
;-- Make sure Lua has "double" numbers
Local x = 2/3
Local Lua_has_double = x * 5 > 3 And x * 4 < 3 And get_precision(1.0) >= 53

If sha_debug Then DebugPrint("Has double: ", Lua_has_double)

;-- Q:
;--    SHA2 was designed for FPU-less machines.
;--    So, why floating point numbers are needed for this module?
;-- A:
;--    53-bit "double" numbers are useful to calculate "magic numbers" used in SHA.
;--    I prefer to write 50 LOC "magic numbers calculator" instead of storing more than 200 constants explicitly in this source file.
Local int_prec, Lua_has_integers = get_precision(1)
Local Lua_has_int64 = (Lua_has_integers And int_prec = 64)
Local Lua_has_int32 = (Lua_has_integers And int_prec = 32)

If sha_debug Then DebugPrint("Has int64: ", Lua_has_int64)
If sha_debug Then DebugPrint("Has int32: ", Lua_has_int32)

;=================================================
;=================================================
; ---------------------------------------------------
; HANDLER FOR BUG IN ARM DEVICES FOR BITWISE OPERATIONS
Local handle_hw_bug = True
Local v = GetVersion()
If v.platform = "Win32" Then handle_hw_bug = False
; ---------------------------------------------------
; Manual settings
Local method = "Emulating bitwise operators using look-up table"
Local branch = "EMUL"

Local max32bit = 4294967295
Local max48bit = 2^48-1

Local overflow  = max32bit + 1
Local overflow2 = max48bit + 1
Local mb = 0 ; Dal test sembra che i numeri non superino mai i 49 bit

Local cache    = {}
Local bitchecker = {}
; Init bit checker
For Local b = 32 To 63
  bitchecker[b] =  { _max = 2^b-1, overflow = 2^b }
Next
Local force32bit =
  Function(n)
    If HaveItem(cache, n) Then Return(cache[n])
    If n < overflow Then Return(n)
    
    DisableLinehook()
    Local i = n
    For Local b = 51 To 32 Step -1
      If n > bitchecker[b]._max
        While n > bitchecker[b]._max
          n = n-bitchecker[b].overflow
          ;If b>mb Then mb = b ; Serve a vedere quanti bit al massimo abbiamo
        Wend
      EndIf
    Next
    cache[i] = n
    
    EnableLineHook()

    Return(n)
    
  EndFunction

If Not(handle_hw_bug) Then force32bit = Function(n) Return(n) EndFunction
;=================================================
;=================================================
  
Function _SHL(x, y)
  Local n  = force32bit(x)
  Local r = Shl(n, y)
  Return(r) 
EndFunction
Function _SHR(x, y)
  Local n = force32bit(x)
  Local r = Shr(n, y)
  Return(r)
EndFunction
Function _ROL(x, y)
  Local n = force32bit(x)
  Local r = Rol(n, y)
  Return(r) 
EndFunction
Function _ROR(x, y) 
  Local n = force32bit(x)
  Local r = Ror(n, y)
  Return(r) 
EndFunction
Function _AND(x, y)
  Local n1, n2 = x, y
  If x>0 Then n1 = force32Bit(x)
  If y>0 Then n2 = force32Bit(y)
  Local r = n1 & n2
  Return(r) 
EndFunction
Function _OR(x, y)
  Local n1 = force32Bit(x)
  Local n2 = force32Bit(y)
  Local r = n1 | n2
  Return(r) 
EndFunction
Function _NOT(x)
  Local n1 = force32Bit(x)
  Local r = ~n1
  Return(r) 
EndFunction
Function _XOR(a, b, c, d, e)
  If Not(IsNil(e))
    Local n1 = force32Bit(a)
    Local n2 = force32Bit(b)
    Local n3 = force32Bit(c)
    Local n4 = force32Bit(d)
    Local n5 = force32Bit(e)
    Local r = BitXor(BitXor(BitXor(BitXor(n1, n2), n3), n4), n5)
    Return(r)
  ElseIf Not(IsNil(d))
    Local n1 = force32Bit(a)
    Local n2 = force32Bit(b)
    Local n3 = force32Bit(c)
    Local n4 = force32Bit(d)
    Local r = BitXor(BitXor(BitXor(n1, n2), n3), n4)
    Return(r)
  ElseIf Not(IsNil(c))
    Local n1 = force32Bit(a)
    Local n2 = force32Bit(b)
    Local n3 = force32Bit(c)
    Local r = BitXor(BitXor(n1, n2), n3)
    Return(r)
  Else
    Local n1 = force32Bit(a)
    Local n2 = force32Bit(b)
    Local r = BitXor(n1, n2)
    Return(r)
  EndIf
EndFunction

/*
If EmulateBitOps
  _SHL = BA_Shl
  _SHR = BA_Shr
EndIf


Local v = 5140528219
DebugPrint("Conversion timings")
StartTimer(1)
DisableLineHook()
For Local i = 1 To 10000
  ;numToBitArray(v)
  n = BA_Shl(v, 1)
Next
EnableLineHook()
Local t = GetTimer(1)
DebugPrint("Total time (x10000): ", t)

DebugPrint("test number: ", v, BinStr(v))
DebugPrint("Testing Shift Left")
Local r = BA_Shl(v, 1)
DebugPrint("SRC ", BinStr(v), v)
DebugPrint("=>  ", BinStr(r), r)
DebugPrint("Testing Shift Right")
Local r = BA_Shr(v, 1)
DebugPrint("SRC ", BinStr(v), v)
DebugPrint("=>  ", BinStr(r), r)
DebugPrint("Shr ", BinStr(Shr(v, 1)))
DebugPrint("Testing Rotate Left")
Local r = BA_Rol(v, 1)
DebugPrint("SRC ", BinStr(v), v)
DebugPrint("=>  ", BinStr(r), r)
DebugPrint("Testing Rotate Right")
Local r = BA_Ror(v, 1)
DebugPrint("SRC ", BinStr(v), v)
DebugPrint("=>  ", BinStr(r), r)
DebugPrint("Testing And")
Local n2 = "11001100110011001100110011001100"
Local r = BA_And(v, ToNumber(n2, 2))
DebugPrint("SRC ", BinStr(v), v)
DebugPrint("AND ", n2)
DebugPrint("=>  ", BinStr(r), r)
DebugPrint("Testing Or")
Local n2 = "11001100110011001100110011001100"
Local r = BA_Or(v, ToNumber(n2, 2))
DebugPrint("SRC ", BinStr(v), v)
DebugPrint("Or  ", n2)
DebugPrint("=>  ", BinStr(r), r)
DebugPrint("Testing Xor")
Local n2 = "11001100110011001100110011001100"
Local r = BA_Xor(v, ToNumber(n2, 2))
DebugPrint("SRC ", BinStr(v), v)
DebugPrint("Xor ", n2)
DebugPrint("=>  ", BinStr(r), r)

;===========================================================================
; END OF EMULATION CODE
;===========================================================================
*/

/*
; Try to split it
Local max32bit = 4294967295
Local low = v & max32bit
DebugPrint(low, BinStr(low), BinStr(845560923))
Local low2 = v - max32bit
DebugPrint(low2, BinStr(low2), BinStr(845560923))

Local high = v-low
DebugPrint(high)
For i = 1 To 32
  high = high/2
Next
DebugPrint(BinStr(high) .. " " .. BinStr(low))
DebugPrint("SHIFT LEFT")
high = Shl(high, 1)
If BitTest(low, 31) Then BitSet(high, 0)
low  = Shl(low, 1)
DebugPrint(BinStr(high) .. " " .. BinStr(low))

For i = 1 To 32
  high = high * 2
Next
Local n = high + low
DebugPrint(n)

DebugPrint(v, BinStr(v))
DebugPrint(v, _ROL(v, 13), _ROL(v, 15), ROL(v, 10))
*/



Function _XOR_BYTE(x, y)
  x = x & ToNumber("11111111", 2)
  y = y & ToNumber("11111111", 2)
  Local r = x + y - 2 * AND_of_two_bytes[x + y * 256]
  Return(r)
EndFunction

Function _HEX(x)
  ;Return(FormatStr("%08x", x % 4294967296))
  Return(FormatStr("%08x", _MOD(x, 4294967296)))
EndFunction

Function XOR32A5(x)
  ;Return(_XOR(x, 0xA5A5A5A5) % 4294967296)
  Return(_MOD(_XOR(x, 0xA5A5A5A5), 4294967296))
EndFunction

Function create_array_of_lanes()
  Return({ -999, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 })
  ; Added extra -999 beacuse of indexing differences
EndFunction

;--------------------------------------------------------------------------------
;-- CREATING OPTIMIZED INNER LOOP
;--------------------------------------------------------------------------------

;-- Inner loop functions
Local sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed

Local sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}
Local sha2_H_ext256 = {[224] = {}, [256] = sha2_H_hi}
Local sha2_H_ext512_lo, sha2_H_ext512_hi = {[384] = {}, [512] = sha2_H_lo}, {[384] = {}, [512] = sha2_H_hi}
Local md5_K, md5_sha1_H = {}, {-999, 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0}
;                              Added extra -999 for indexing differences
Local md5_next_shift = {-999, 0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21}
;                       Added extra -999 for indexing differences
Local HEX64, XOR64A5, lanes_index_base  ; -- defined only for branches that internally use 64-bit integers: "INT64" and "FFI"
Local common_W = {}    ;-- temporary table shared between all calculations (to avoid creating new temporary table every time)
Local K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0

Local Function build_keccak_format(elem)
   Local keccak_format = {}
   For _, size In IPairs({0, 1, 9, 13, 17, 18, 21}) ; Added 0 at 0 pos
      keccak_format[size] = "<"..string_rep(elem, size)
   Next
   Return(keccak_format)
EndFunction

Function sha256_feed_64(H, str, offs, size)
  ;-- offs >= 0, size >= 0, size is multiple of 64  
  Local W, K = common_W, sha2_K_hi
  Local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
  For pos = offs To offs + size - 1 Step 64
    Local pos = pos
    For j = 1 To 16
      pos = pos + 4
      Local tmp = byte(str, pos - 3, pos) ; byte is customized
      ;If sha_debug Then DebugPrint("pos:" .. pos, "j:" .. j, "tmp[]:" .. tmp[0] .. " " .. tmp[1] .. " " .. tmp[2] .. " " .. tmp[3])
      Local a, b, c, d = tmp[0], tmp[1], tmp[2], tmp[3]
      W[j] = ((a * 256 + b) * 256 + c) * 256 + d
    Next
    For j = 17 To 64
      Local a, b = W[j-15], W[j-2]
      Local r1 = _ROR(a, 7)
      Local r2 = _ROL(a, 14)
      Local r3 = _SHR(a, 3)
      Local r4 = _ROL(b, 15)
      Local r5 = _ROL(b, 13)
      Local r6 = _SHR(b, 10)
      Local x1 = _XOR(r1, r2, r3)
      Local x2 = _XOR(r4, r5, r6)
      W[j] = x1 + x2 + W[j-7] + W[j-16]
      
    Next
    Local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8
    For j = 1 To 64
      Local z = _XOR(_ROR(e, 6), _ROR(e, 11), _ROL(e, 7)) + _AND(e, f) + _AND(_NOT(e), g) + h + K[j] + W[j]
      h = g
      g = f
      f = e
      e = z + d
      d = c
      c = b
      b = a
      a = z + _AND(d, c) + _AND(a, _XOR(d, c)) + _XOR(_ROR(a, 2), _ROR(a, 13), _ROL(a, 10))
    Next
    h1, h2, h3, h4 = _MOD((a + h1), 4294967296), _MOD((b + h2), 4294967296), _MOD((c + h3), 4294967296), _MOD((d + h4), 4294967296)
    ; h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296
    h5, h6, h7, h8 = _MOD((e + h5), 4294967296), _MOD((f + h6), 4294967296), _MOD((g + h7), 4294967296), _MOD((h + h8), 4294967296)
    ; h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296
  Next
  H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8
  
EndFunction

Function sha512_feed_128(H_lo, H_hi, str, offs, size)
  ;-- offs >= 0, size >= 0, size is multiple of 128
  ;-- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]
  Local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi
  Local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]
  Local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]
  For pos = offs To offs + size - 1, 128
    Local pos = pos
    For j = 1 To 16*2
      pos = pos + 4
      Local tmp = byte(str, pos - 3, pos) ; byte is customized
      Local a, b, c, d = tmp[0], tmp[1], tmp[2], tmp[3]      
      W[j] = ((a * 256 + b) * 256 + c) * 256 + d
    Next
    For jj = 17*2 To 80*2 Step 2
      Local a_lo, a_hi, b_lo, b_hi = W[jj-30], W[jj-31], W[jj-4], W[jj-5]
      ;local tmp1 =  XOR( SHR(a_lo, 1) +  SHL(a_hi, 31),  SHR(a_lo, 8) +  SHL(a_hi, 24),  SHR(a_lo, 7) +  SHL(a_hi, 25)) % 4294967296 +  XOR( SHR(b_lo, 19) +  SHL(b_hi, 13),  SHL(b_lo, 3) +  SHR(b_hi, 29),  SHR(b_lo, 6) +  SHL(b_hi, 26)) % 4294967296 + W[jj-14] + W[jj-32]
      Local tmp1 = _XOR(_SHR(a_lo, 1) + _SHL(a_hi, 31), _SHR(a_lo, 8) + _SHL(a_hi, 24), _SHR(a_lo, 7) + _SHL(a_hi, 25)) % 4294967296 + _XOR(_SHR(b_lo, 19) + _SHL(b_hi, 13), _SHL(b_lo, 3) + _SHR(b_hi, 29), _SHR(b_lo, 6) + _SHL(b_hi, 26)) % 4294967296 + W[jj-14] + W[jj-32]
      Local tmp2 = _MOD(tmp1, 4294967296)
      W[jj-1] = _XOR(_SHR(a_hi, 1) + _SHL(a_lo, 31), _SHR(a_hi, 8) + _SHL(a_lo, 24), _SHR(a_hi, 7)) + _XOR(_SHR(b_hi, 19) + _SHL(b_lo, 13), _SHL(b_hi, 3) + _SHR(b_lo, 29), _SHR(b_hi, 6)) + W[jj-15] + W[jj-33] + (tmp1 - tmp2) / 4294967296
      W[jj] = tmp2
    Next
    Local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
    Local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
    For j = 1 To 80
      Local jj = 2*j
      Local tmp1 = _XOR(_SHR(e_lo, 14) + _SHL(e_hi, 18), _SHR(e_lo, 18) + _SHL(e_hi, 14), _SHL(e_lo, 23) + _SHR(e_hi, 9)) % 4294967296 + _MOD((_AND(e_lo, f_lo) + _AND(_NOT(e_lo), g_lo)), 4294967296) + h_lo + K_lo[j] + W[jj]
      Local z_lo = _MOD(tmp1, 4294967296)
      Local z_hi = _XOR(_SHR(e_hi, 14) + _SHL(e_lo, 18), _SHR(e_hi, 18) + _SHL(e_lo, 14), _SHL(e_hi, 23) + _SHR(e_lo, 9)) + _AND(e_hi, f_hi) + _AND(_NOT(e_hi), g_hi) + h_hi + K_hi[j] + W[jj-1] + (tmp1 - z_lo) / 4294967296
      h_lo = g_lo
      h_hi = g_hi
      g_lo = f_lo
      g_hi = f_hi
      f_lo = e_lo
      f_hi = e_hi
      tmp1 = z_lo + d_lo
      e_lo = _MOD(tmp1, 4294967296)
      e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296
      d_lo = c_lo
      d_hi = c_hi
      c_lo = b_lo
      c_hi = b_hi
      b_lo = a_lo
      b_hi = a_hi
      tmp1 = z_lo + _MOD((_AND(d_lo, c_lo) + _AND(b_lo, _XOR(d_lo, c_lo))), 4294967296) + _MOD(_XOR(_SHR(b_lo, 28) + _SHL(b_hi, 4), _SHL(b_lo, 30) + _SHR(b_hi, 2), _SHL(b_lo, 25) + _SHR(b_hi, 7)), 4294967296)
      a_lo = _MOD(tmp1, 4294967296)
      a_hi = z_hi + (_AND(d_hi, c_hi) + _AND(b_hi, _XOR(d_hi, c_hi))) + _XOR(_SHR(b_hi, 28) + _SHL(b_lo, 4), _SHL(b_hi, 30) + _SHR(b_lo, 2), _SHL(b_hi, 25) + _SHR(b_lo, 7)) + (tmp1 - a_lo) / 4294967296
    Next
    a_lo = h1_lo + a_lo
    h1_lo = _MOD(a_lo, 4294967296)
    h1_hi = _MOD((h1_hi + a_hi + (a_lo - h1_lo) / 4294967296), 4294967296)
    a_lo = h2_lo + b_lo
    h2_lo = _MOD(a_lo, 4294967296)
    h2_hi = _MOD((h2_hi + b_hi + (a_lo - h2_lo) / 4294967296), 4294967296)
    a_lo = h3_lo + c_lo
    h3_lo = _MOD(a_lo, 4294967296)
    h3_hi = _MOD((h3_hi + c_hi + (a_lo - h3_lo) / 4294967296), 4294967296)
    a_lo = h4_lo + d_lo
    h4_lo = _MOD(a_lo, 4294967296)
    h4_hi = _MOD((h4_hi + d_hi + (a_lo - h4_lo) / 4294967296), 4294967296)
    a_lo = h5_lo + e_lo
    h5_lo = _MOD(a_lo, 4294967296)
    h5_hi = _MOD((h5_hi + e_hi + (a_lo - h5_lo) / 4294967296), 4294967296)
    a_lo = h6_lo + f_lo
    h6_lo = _MOD(a_lo, 4294967296)
    h6_hi = _MOD((h6_hi + f_hi + (a_lo - h6_lo) / 4294967296), 4294967296)
    a_lo = h7_lo + g_lo
    h7_lo = _MOD(a_lo, 4294967296)
    h7_hi = _MOD((h7_hi + g_hi + (a_lo - h7_lo) / 4294967296), 4294967296)
    a_lo = h8_lo + h_lo
    h8_lo = _MOD(a_lo, 4294967296)
    h8_hi = _MOD((h8_hi + h_hi + (a_lo - h8_lo) / 4294967296), 4294967296)
  Next
  H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
  H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
EndFunction

Function md5_feed_64(H, str, offs, size)
  ;-- offs >= 0, size >= 0, size is multiple of 64
  Local W, K, md5_next_shift = common_W, md5_K, md5_next_shift
  Local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]
  For pos = offs To offs + size - 1 Step 64
    Local pos = pos
    For j = 1 To 16
      pos = pos + 4
      Local tmp = byte(str, pos - 3, pos) ; byte is customized
      Local a, b, c, d = tmp[0], tmp[1], tmp[2], tmp[3]      
      W[j] = ((d * 256 + c) * 256 + b) * 256 + a
    Next
    Local a, b, c, d = h1, h2, h3, h4
    Local s = 32-7
    For j = 1 To 16
      Local F = _ROR(_AND(b, c) + _AND(_NOT(b), d) + a + K[j] + W[j], s) + b
      s = md5_next_shift[s]
      a = d
      d = c
      c = b
      b = F
    Next
    s = 32-5
    For j = 17 To 32
      Local F = _ROR(_AND(d, b) + _AND(_NOT(d), c) + a + K[j] + W[(5*j-4) % 16 + 1], s) + b
      s = md5_next_shift[s]
      a = d
      d = c
      c = b
      b = F
    Next
    s = 32-4
    For j = 33 To 48
      Local F = _ROR(_XOR(_XOR(b, c), d) + a + K[j] + W[(3*j+2) % 16 + 1], s) + b
      s = md5_next_shift[s]
      a = d
      d = c
      c = b
      b = F
    Next
    s = 32-6
    For j = 49 To 64
      Local F = _ROR(_XOR(c, _OR(b, _NOT(d))) + a + K[j] + W[(j*7-7) % 16 + 1], s) + b
      s = md5_next_shift[s]
      a = d
      d = c
      c = b
      b = F
    Next
    h1 = _MOD((a + h1), 4294967296)
    h2 = _MOD((b + h2), 4294967296)
    h3 = _MOD((c + h3), 4294967296)
    h4 = _MOD((d + h4), 4294967296)
  Next
  H[1], H[2], H[3], H[4] = h1, h2, h3, h4
EndFunction

Function sha1_feed_64(H, str, offs, size)
  ;-- offs >= 0, size >= 0, size is multiple of 64
  Local W = common_W
  Local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]
  For pos = offs To offs + size - 1 Step 64
    Local pos = pos
    For j = 1 To 16
      pos = pos + 4
      Local tmp = byte(str, pos - 3, pos) ; byte is customized
      Local a, b, c, d = tmp[0], tmp[1], tmp[2], tmp[3]      
      W[j] = ((a * 256 + b) * 256 + c) * 256 + d
    Next
    For j = 17 To 80
      W[j] = _ROL(_XOR(W[j-3], W[j-8], W[j-14], W[j-16]), 1)
    Next
    Local a, b, c, d, e = h1, h2, h3, h4, h5
    For j = 1 To 20
      Local z = _ROL(a, 5) + _AND(b, c) + _AND(_NOT(b), d) + 0x5A827999 + W[j] + e ; -- constant = floor(2^30 * sqrt(2))
      e = d
      d = c
      c = _ROR(b, 2)
      b = a
      a = z
    Next
    For j = 21 To 40
      Local z = _ROL(a, 5) + _XOR(b, c, d) + 0x6ED9EBA1 + W[j] + e ; -- 2^30 * sqrt(3)
      e = d
      d = c
      c = _ROR(b, 2)
      b = a
      a = z
    Next
    For j = 41 To 60
      Local z = _ROL(a, 5) + _AND(d, c) + _AND(b, _XOR(d, c)) + 0x8F1BBCDC + W[j] + e ;-- 2^30 * sqrt(5)
      e = d
      d = c
      c = _ROR(b, 2)
      b = a
      a = z
    Next
    For j = 61 To 80
      Local z = _ROL(a, 5) + _XOR(b, c, d) + 0xCA62C1D6 + W[j] + e ;-- 2^30 * sqrt(10)
      e = d
      d = c
      c = _ROR(b, 2)
      b = a
      a = z
    Next
    h1 = _MOD((a + h1), 4294967296)
    h2 = _MOD((b + h2), 4294967296)
    h3 = _MOD((c + h3), 4294967296)
    h4 = _MOD((d + h4), 4294967296)
    h5 = _MOD((e + h5), 4294967296)
  Next
  H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5
EndFunction

Function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)
  ;-- This is an example of a Lua function having 79 local variables :-)
  ;-- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8

  Local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi
  Local qwords_qty = block_size_in_bytes / 8
  For pos = offs To offs + size - 1 Step block_size_in_bytes
    Local pos = pos
    For j = 1 To qwords_qty
      Local tmp = byte(str, pos+1, pos+4) ; byte is customized
      Local a, b, c, d = tmp[0], tmp[1], tmp[2], tmp[3]
      lanes_lo[j] = _XOR(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)
      pos = pos + 8
      tmp = byte(str, pos - 3, pos) ; byte is customized
      a, b, c, d = tmp[0], tmp[1], tmp[2], tmp[3]      
      lanes_hi[j] = _XOR(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)
    Next
    Local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi,
          L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi,
          L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi =
          lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5],
          lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10],
          lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15],
          lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20],
          lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]
    
    For round_idx = 1 To 24
      Local C1_lo = _XOR(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)
      Local C1_hi = _XOR(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)
      Local C2_lo = _XOR(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)
      Local C2_hi = _XOR(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)
      Local C3_lo = _XOR(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)
      Local C3_hi = _XOR(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)
      Local C4_lo = _XOR(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)
      Local C4_hi = _XOR(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)
      Local C5_lo = _XOR(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)
      Local C5_hi = _XOR(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)
      Local D_lo = _XOR(C1_lo, C3_lo * 2 + (C3_hi % 2^32 - C3_hi % 2^31) / 2^31)
      Local D_hi = _XOR(C1_hi, C3_hi * 2 + (C3_lo % 2^32 - C3_lo % 2^31) / 2^31)
      Local T0_lo = _XOR(D_lo, L02_lo)
      Local T0_hi = _XOR(D_hi, L02_hi)
      Local T1_lo = _XOR(D_lo, L07_lo)
      Local T1_hi = _XOR(D_hi, L07_hi)
      Local T2_lo = _XOR(D_lo, L12_lo)
      Local T2_hi = _XOR(D_hi, L12_hi)
      Local T3_lo = _XOR(D_lo, L17_lo)
      Local T3_hi = _XOR(D_hi, L17_hi)
      Local T4_lo = _XOR(D_lo, L22_lo)
      Local T4_hi = _XOR(D_hi, L22_hi)
      L02_lo = (T1_lo % 2^32 - T1_lo % 2^20) / 2^20 + T1_hi * 2^12
      L02_hi = (T1_hi % 2^32 - T1_hi % 2^20) / 2^20 + T1_lo * 2^12
      L07_lo = (T3_lo % 2^32 - T3_lo % 2^19) / 2^19 + T3_hi * 2^13
      L07_hi = (T3_hi % 2^32 - T3_hi % 2^19) / 2^19 + T3_lo * 2^13
      L12_lo = T0_lo * 2 + (T0_hi % 2^32 - T0_hi % 2^31) / 2^31
      L12_hi = T0_hi * 2 + (T0_lo % 2^32 - T0_lo % 2^31) / 2^31
      L17_lo = T2_lo * 2^10 + (T2_hi % 2^32 - T2_hi % 2^22) / 2^22
      L17_hi = T2_hi * 2^10 + (T2_lo % 2^32 - T2_lo % 2^22) / 2^22
      L22_lo = T4_lo * 2^2 + (T4_hi % 2^32 - T4_hi % 2^30) / 2^30
      L22_hi = T4_hi * 2^2 + (T4_lo % 2^32 - T4_lo % 2^30) / 2^30
      D_lo = _XOR(C2_lo, C4_lo * 2 + (C4_hi % 2^32 - C4_hi % 2^31) / 2^31)
      D_hi = _XOR(C2_hi, C4_hi * 2 + (C4_lo % 2^32 - C4_lo % 2^31) / 2^31)
      T0_lo = _XOR(D_lo, L03_lo)
      T0_hi = _XOR(D_hi, L03_hi)
      T1_lo = _XOR(D_lo, L08_lo)
      T1_hi = _XOR(D_hi, L08_hi)
      T2_lo = _XOR(D_lo, L13_lo)
      T2_hi = _XOR(D_hi, L13_hi)
      T3_lo = _XOR(D_lo, L18_lo)
      T3_hi = _XOR(D_hi, L18_hi)
      T4_lo = _XOR(D_lo, L23_lo)
      T4_hi = _XOR(D_hi, L23_hi)
      L03_lo = (T2_lo % 2^32 - T2_lo % 2^21) / 2^21 + T2_hi * 2^11
      L03_hi = (T2_hi % 2^32 - T2_hi % 2^21) / 2^21 + T2_lo * 2^11
      L08_lo = (T4_lo % 2^32 - T4_lo % 2^3) / 2^3 + T4_hi * 2^29 % 2^32
      L08_hi = (T4_hi % 2^32 - T4_hi % 2^3) / 2^3 + T4_lo * 2^29 % 2^32
      L13_lo = T1_lo * 2^6 + (T1_hi % 2^32 - T1_hi % 2^26) / 2^26
      L13_hi = T1_hi * 2^6 + (T1_lo % 2^32 - T1_lo % 2^26) / 2^26
      L18_lo = T3_lo * 2^15 + (T3_hi % 2^32 - T3_hi % 2^17) / 2^17
      L18_hi = T3_hi * 2^15 + (T3_lo % 2^32 - T3_lo % 2^17) / 2^17
      L23_lo = (T0_lo % 2^32 - T0_lo % 2^2) / 2^2 + T0_hi * 2^30 % 2^32
      L23_hi = (T0_hi % 2^32 - T0_hi % 2^2) / 2^2 + T0_lo * 2^30 % 2^32
      D_lo = _XOR(C3_lo, C5_lo * 2 + (C5_hi % 2^32 - C5_hi % 2^31) / 2^31)
      D_hi = _XOR(C3_hi, C5_hi * 2 + (C5_lo % 2^32 - C5_lo % 2^31) / 2^31)
      T0_lo = _XOR(D_lo, L04_lo)
      T0_hi = _XOR(D_hi, L04_hi)
      T1_lo = _XOR(D_lo, L09_lo)
      T1_hi = _XOR(D_hi, L09_hi)
      T2_lo = _XOR(D_lo, L14_lo)
      T2_hi = _XOR(D_hi, L14_hi)
      T3_lo = _XOR(D_lo, L19_lo)
      T3_hi = _XOR(D_hi, L19_hi)
      T4_lo = _XOR(D_lo, L24_lo)
      T4_hi = _XOR(D_hi, L24_hi)
      L04_lo = T3_lo * 2^21 % 2^32 + (T3_hi % 2^32 - T3_hi % 2^11) / 2^11
      L04_hi = T3_hi * 2^21 % 2^32 + (T3_lo % 2^32 - T3_lo % 2^11) / 2^11
      L09_lo = T0_lo * 2^28 % 2^32 + (T0_hi % 2^32 - T0_hi % 2^4) / 2^4
      L09_hi = T0_hi * 2^28 % 2^32 + (T0_lo % 2^32 - T0_lo % 2^4) / 2^4
      L14_lo = T2_lo * 2^25 % 2^32 + (T2_hi % 2^32 - T2_hi % 2^7) / 2^7
      L14_hi = T2_hi * 2^25 % 2^32 + (T2_lo % 2^32 - T2_lo % 2^7) / 2^7
      L19_lo = (T4_lo % 2^32 - T4_lo % 2^8) / 2^8 + T4_hi * 2^24 % 2^32
      L19_hi = (T4_hi % 2^32 - T4_hi % 2^8) / 2^8 + T4_lo * 2^24 % 2^32
      L24_lo = (T1_lo % 2^32 - T1_lo % 2^9) / 2^9 + T1_hi * 2^23 % 2^32
      L24_hi = (T1_hi % 2^32 - T1_hi % 2^9) / 2^9 + T1_lo * 2^23 % 2^32
      D_lo = _XOR(C4_lo, C1_lo * 2 + (C1_hi % 2^32 - C1_hi % 2^31) / 2^31)
      D_hi = _XOR(C4_hi, C1_hi * 2 + (C1_lo % 2^32 - C1_lo % 2^31) / 2^31)
      T0_lo = _XOR(D_lo, L05_lo)
      T0_hi = _XOR(D_hi, L05_hi)
      T1_lo = _XOR(D_lo, L10_lo)
      T1_hi = _XOR(D_hi, L10_hi)
      T2_lo = _XOR(D_lo, L15_lo)
      T2_hi = _XOR(D_hi, L15_hi)
      T3_lo = _XOR(D_lo, L20_lo)
      T3_hi = _XOR(D_hi, L20_hi)
      T4_lo = _XOR(D_lo, L25_lo)
      T4_hi = _XOR(D_hi, L25_hi)
      L05_lo = T4_lo * 2^14 + (T4_hi % 2^32 - T4_hi % 2^18) / 2^18
      L05_hi = T4_hi * 2^14 + (T4_lo % 2^32 - T4_lo % 2^18) / 2^18
      L10_lo = T1_lo * 2^20 % 2^32 + (T1_hi % 2^32 - T1_hi % 2^12) / 2^12
      L10_hi = T1_hi * 2^20 % 2^32 + (T1_lo % 2^32 - T1_lo % 2^12) / 2^12
      L15_lo = T3_lo * 2^8 + (T3_hi % 2^32 - T3_hi % 2^24) / 2^24
      L15_hi = T3_hi * 2^8 + (T3_lo % 2^32 - T3_lo % 2^24) / 2^24
      L20_lo = T0_lo * 2^27 % 2^32 + (T0_hi % 2^32 - T0_hi % 2^5) / 2^5
      L20_hi = T0_hi * 2^27 % 2^32 + (T0_lo % 2^32 - T0_lo % 2^5) / 2^5
      L25_lo = (T2_lo % 2^32 - T2_lo % 2^25) / 2^25 + T2_hi * 2^7
      L25_hi = (T2_hi % 2^32 - T2_hi % 2^25) / 2^25 + T2_lo * 2^7
      D_lo = _XOR(C5_lo, C2_lo * 2 + (C2_hi % 2^32 - C2_hi % 2^31) / 2^31)
      D_hi = _XOR(C5_hi, C2_hi * 2 + (C2_lo % 2^32 - C2_lo % 2^31) / 2^31)
      T1_lo = _XOR(D_lo, L06_lo)
      T1_hi = _XOR(D_hi, L06_hi)
      T2_lo = _XOR(D_lo, L11_lo)
      T2_hi = _XOR(D_hi, L11_hi)
      T3_lo = _XOR(D_lo, L16_lo)
      T3_hi = _XOR(D_hi, L16_hi)
      T4_lo = _XOR(D_lo, L21_lo)
      T4_hi = _XOR(D_hi, L21_hi)
      L06_lo = T2_lo * 2^3 + (T2_hi % 2^32 - T2_hi % 2^29) / 2^29
      L06_hi = T2_hi * 2^3 + (T2_lo % 2^32 - T2_lo % 2^29) / 2^29
      L11_lo = T4_lo * 2^18 + (T4_hi % 2^32 - T4_hi % 2^14) / 2^14
      L11_hi = T4_hi * 2^18 + (T4_lo % 2^32 - T4_lo % 2^14) / 2^14
      L16_lo = (T1_lo % 2^32 - T1_lo % 2^28) / 2^28 + T1_hi * 2^4
      L16_hi = (T1_hi % 2^32 - T1_hi % 2^28) / 2^28 + T1_lo * 2^4
      L21_lo = (T3_lo % 2^32 - T3_lo % 2^23) / 2^23 + T3_hi * 2^9
      L21_hi = (T3_hi % 2^32 - T3_hi % 2^23) / 2^23 + T3_lo * 2^9
      L01_lo = _XOR(D_lo, L01_lo)
      L01_hi = _XOR(D_hi, L01_hi)
      L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = _XOR(L01_lo, _AND(_NOT(L02_lo), L03_lo)), _XOR(L02_lo, _AND(_NOT(L03_lo), L04_lo)), _XOR(L03_lo, _AND(_NOT(L04_lo), L05_lo)), _XOR(L04_lo, _AND(_NOT(L05_lo), L01_lo)), _XOR(L05_lo, _AND(_NOT(L01_lo), L02_lo))
      L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = _XOR(L01_hi, _AND(_NOT(L02_hi), L03_hi)), _XOR(L02_hi, _AND(_NOT(L03_hi), L04_hi)), _XOR(L03_hi, _AND(_NOT(L04_hi), L05_hi)), _XOR(L04_hi, _AND(_NOT(L05_hi), L01_hi)), _XOR(L05_hi, _AND(_NOT(L01_hi), L02_hi))
      L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = _XOR(L09_lo, _AND(_NOT(L10_lo), L06_lo)), _XOR(L10_lo, _AND(_NOT(L06_lo), L07_lo)), _XOR(L06_lo, _AND(_NOT(L07_lo), L08_lo)), _XOR(L07_lo, _AND(_NOT(L08_lo), L09_lo)), _XOR(L08_lo, _AND(_NOT(L09_lo), L10_lo))
      L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = _XOR(L09_hi, _AND(_NOT(L10_hi), L06_hi)), _XOR(L10_hi, _AND(_NOT(L06_hi), L07_hi)), _XOR(L06_hi, _AND(_NOT(L07_hi), L08_hi)), _XOR(L07_hi, _AND(_NOT(L08_hi), L09_hi)), _XOR(L08_hi, _AND(_NOT(L09_hi), L10_hi))
      L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = _XOR(L12_lo, _AND(_NOT(L13_lo), L14_lo)), _XOR(L13_lo, _AND(_NOT(L14_lo), L15_lo)), _XOR(L14_lo, _AND(_NOT(L15_lo), L11_lo)), _XOR(L15_lo, _AND(_NOT(L11_lo), L12_lo)), _XOR(L11_lo, _AND(_NOT(L12_lo), L13_lo))
      L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = _XOR(L12_hi, _AND(_NOT(L13_hi), L14_hi)), _XOR(L13_hi, _AND(_NOT(L14_hi), L15_hi)), _XOR(L14_hi, _AND(_NOT(L15_hi), L11_hi)), _XOR(L15_hi, _AND(_NOT(L11_hi), L12_hi)), _XOR(L11_hi, _AND(_NOT(L12_hi), L13_hi))
      L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = _XOR(L20_lo, _AND(_NOT(L16_lo), L17_lo)), _XOR(L16_lo, _AND(_NOT(L17_lo), L18_lo)), _XOR(L17_lo, _AND(_NOT(L18_lo), L19_lo)), _XOR(L18_lo, _AND(_NOT(L19_lo), L20_lo)), _XOR(L19_lo, _AND(_NOT(L20_lo), L16_lo))
      L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = _XOR(L20_hi, _AND(_NOT(L16_hi), L17_hi)), _XOR(L16_hi, _AND(_NOT(L17_hi), L18_hi)), _XOR(L17_hi, _AND(_NOT(L18_hi), L19_hi)), _XOR(L18_hi, _AND(_NOT(L19_hi), L20_hi)), _XOR(L19_hi, _AND(_NOT(L20_hi), L16_hi))
      L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = _XOR(L23_lo, _AND(_NOT(L24_lo), L25_lo)), _XOR(L24_lo, _AND(_NOT(L25_lo), L21_lo)), _XOR(L25_lo, _AND(_NOT(L21_lo), L22_lo)), _XOR(L21_lo, _AND(_NOT(L22_lo), L23_lo)), _XOR(L22_lo, _AND(_NOT(L23_lo), L24_lo))
      L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = _XOR(L23_hi, _AND(_NOT(L24_hi), L25_hi)), _XOR(L24_hi, _AND(_NOT(L25_hi), L21_hi)), _XOR(L25_hi, _AND(_NOT(L21_hi), L22_hi)), _XOR(L21_hi, _AND(_NOT(L22_hi), L23_hi)), _XOR(L22_hi, _AND(_NOT(L23_hi), L24_hi))
      L01_lo = _XOR(L01_lo, RC_lo[round_idx])
      L01_hi = L01_hi + RC_hi[round_idx] ;-- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR
    Next
    lanes_lo[1]  = L01_lo
    lanes_hi[1]  = L01_hi
    lanes_lo[2]  = L02_lo
    lanes_hi[2]  = L02_hi
    lanes_lo[3]  = L03_lo
    lanes_hi[3]  = L03_hi
    lanes_lo[4]  = L04_lo
    lanes_hi[4]  = L04_hi
    lanes_lo[5]  = L05_lo
    lanes_hi[5]  = L05_hi
    lanes_lo[6]  = L06_lo
    lanes_hi[6]  = L06_hi
    lanes_lo[7]  = L07_lo
    lanes_hi[7]  = L07_hi
    lanes_lo[8]  = L08_lo
    lanes_hi[8]  = L08_hi
    lanes_lo[9]  = L09_lo
    lanes_hi[9]  = L09_hi
    lanes_lo[10] = L10_lo
    lanes_hi[10] = L10_hi
    lanes_lo[11] = L11_lo
    lanes_hi[11] = L11_hi
    lanes_lo[12] = L12_lo
    lanes_hi[12] = L12_hi
    lanes_lo[13] = L13_lo
    lanes_hi[13] = L13_hi
    lanes_lo[14] = L14_lo
    lanes_hi[14] = L14_hi
    lanes_lo[15] = L15_lo
    lanes_hi[15] = L15_hi
    lanes_lo[16] = L16_lo
    lanes_hi[16] = L16_hi
    lanes_lo[17] = L17_lo
    lanes_hi[17] = L17_hi
    lanes_lo[18] = L18_lo
    lanes_hi[18] = L18_hi
    lanes_lo[19] = L19_lo
    lanes_hi[19] = L19_hi
    lanes_lo[20] = L20_lo
    lanes_hi[20] = L20_hi
    lanes_lo[21] = L21_lo
    lanes_hi[21] = L21_hi
    lanes_lo[22] = L22_lo
    lanes_hi[22] = L22_hi
    lanes_lo[23] = L23_lo
    lanes_hi[23] = L23_hi
    lanes_lo[24] = L24_lo
    lanes_hi[24] = L24_hi
    lanes_lo[25] = L25_lo
    lanes_hi[25] = L25_hi
  Next
EndFunction

;--------------------------------------------------------------------------------
;-- MAGIC NUMBERS CALCULATOR
;--------------------------------------------------------------------------------
;-- Q:
;--    Is 53-bit "double" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?
;-- A:
;--    Yes, 53-bit "double" arithmetic is enough.
;--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton's method.

Local iterations = 0
Block
  iterations = iterations + 1
  Local Function _mul(src1, src2, factor, result_length)

    ;-- src1, src2 - long integers (arrays of digits in base 2^24)
    ;-- factor - small integer
    ;-- returns long integer result (src1 * src2 * factor) and its floating point approximation
    Local result, carry, value, weight = {}, 0.0, 0.0, 1.0
    Local v2_24 = 2^24
    For j = 1 To result_length
      Local src1len = ListItems(src1)-1
      Local src2len = ListItems(src2)-1
      For k = math_max(1, j + 1 - src2len) To math_min(j, src1len)
        carry = carry + factor * src1[k] * src2[j + 1 - k] ; -- "int32" is not enough for multiplication result, that's why "factor" must be of type "double"
      Next
      Local digit = _MOD(carry, v2_24)
      result[j] = floor(digit)
      carry = (carry - digit) / v2_24
      value = value + digit * weight
      weight = weight * v2_24
    Next
    result[0] = -999
    Return(result, value)
  EndFunction

  Local idx, stepp, p, one, sqrt_hi, sqrt_lo = 0, {-999, 4, 1, 2, -2, 2}, 4, {-999, 1}, sha2_H_hi, sha2_H_lo
  ;                                                 Added 0 index entry
  
  Repeat
    iterations = iterations + 1
    p = p + stepp[p % 6]
    Local d = 1
    Repeat
      iterations = iterations + 1
      d = d + stepp[d % 6]
      If d*d > p ; -- next prime number is found
        Local root = p^(1/3)
        Local R = root * 2^40
        R = _mul({-999, R - R % 1}, one, 1.0, 2)
        Local _, delta = _mul(R, _mul(R, R, 1.0, 4), -1.0, 4)
        Local hi = R[2] % 65536 * 65536 + floor(R[1] / 256)
        Local lo = R[1] % 256 * 16777216 + floor(delta * (2^-56 / 3) * root / p)
        If idx < 16
          root = p^(1/2)
          R = root * 2^40
          R = _mul({-999, R - R % 1}, one, 1.0, 2)
          _, delta = _mul(R, R, -1.0, 2)
          Local hi = R[2] % 65536 * 65536 + floor(R[1] / 256)
          Local lo = R[1] % 256 * 16777216 + floor(delta * 2^-17 / root)
          Local idx = idx % 8 + 1
          sha2_H_ext256[224][idx] = lo
          sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor
          If idx > 7
            sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]
          EndIf
        EndIf
        idx = idx + 1
        sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor
        Break
      EndIf
    Until p % d = 0
  Until idx > 79
EndBlock

AND_of_two_bytes = {[0] = 0} ; -- look-up table (256*256 entries)
Local idx = 0
For y = 0 To 127 * 256 Step 256
  For x = y To y + 127
  Local x = x
    x = AND_of_two_bytes[x] * 2
    AND_of_two_bytes[idx] = x
    AND_of_two_bytes[idx + 1] = x
    AND_of_two_bytes[idx + 256] = x
    AND_of_two_bytes[idx + 257] = x + 1
    idx = idx + 2
  Next
  idx = idx + 256
Next

;-- Calculating IVs for SHA512/224 and SHA512/256
For width = 224 To 256 Step 32
   Local H_lo, H_hi = {}
   H_hi = {}
   For j = 1 To 8
      H_lo[j] = XOR32A5(sha2_H_lo[j])
      H_hi[j] = XOR32A5(sha2_H_hi[j])
   Next
   sha512_feed_128(H_lo, H_hi, "SHA-512/"..tostring(width).."\128"..string_rep("\0", 115).."\88", 0, 128)
   sha2_H_ext512_lo[width] = H_lo
   sha2_H_ext512_hi[width] = H_hi
Next

;-- Constants for MD5
Local _MODF = Function(v)
                Local i = Int(v)
                Local d = v-i
                Return(i, d)
              EndFunction
Block
  ;Local sin, abs, modf = math.sin, math.abs, math.modf
  For idx = 1, 64
      ;-- we can't use formula floor(abs(sin(idx))*2^32) because its result may be beyond integer range on Lua built with 32-bit integers
      Local hi, lo = _MODF(abs(sin(idx)) * 2^16)
      md5_K[idx] = hi * 65536 + floor(lo * 2^16)
  Next
EndBlock

;-- Constants for SHA3
Block
  Local sh_reg = 29
  Local Function next_bit()
          Local r = sh_reg % 2
          sh_reg = _XOR_BYTE((sh_reg - r) / 2, 142 * r)
          Return(r)
        EndFunction
  For idx = 1 To 24
    Local lo, m = 0
    For _ = 1 To 6
      m = m And m * m * 2 Or 1
      lo = lo + next_bit() * m
    Next
    Local hi = next_bit() * m
    sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak
  Next

EndBlock

;--------------------------------------------------------------------------------
;-- MAIN FUNCTIONS
;--------------------------------------------------------------------------------

Local Function sha256ext(width, message)
  ;-- Create an instance (private objects for current calculation)  
  Local H, length, tail = CopyTable(sha2_H_ext256[width]), 0.0, ""
  
  Local Function partial(message_part)
    
    If Not(IsNil(message_part))
    
      If Not(IsNil(tail))        
        length = length + ByteLen(message_part) ; #message_part
        
        Local offs = 0
        If tail <> "" And ByteLen(tail) + ByteLen(message_part) >= 64
           offs = 64 - ByteLen(tail)
           sha256_feed_64(H, tail .. sub(message_part, 1, offs), 0, 64)
           tail = ""
        EndIf
        Local size = ByteLen(message_part) - offs
        Local size_tail = size % 64
        sha256_feed_64(H, message_part, offs, size - size_tail)
        tail = tail .. sub(message_part, ByteLen(message_part) + 1 - size_tail)
        Return(partial)
      Else
        DebugPrompt("ERROR: Adding more chunks is not allowed after receiving the result")
      EndIf
    Else
      If Not(IsNil(tail))
        Local final_blocks = {-999, tail, "\128", string_rep("\0", _MOD((-9 - length), 64) + 1)}
        tail = Nil
        ;-- Assuming user data length is shorter than (2^53)-9 bytes
        ;-- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process 2^53 bytes of data by using this Lua script :-)
        ;-- 2^53 bytes = 2^56 bits, so "bit-counter" fits in 7 bytes
        length = length * (8 / 256^7)  ;-- convert "byte-counter" to "bit-counter" and move decimal point to the left
        For j = 4 To 10
          length = Mod(length, 1) * 256
          final_blocks[j] = char(floor(length))
        Next
        final_blocks = table_concat(final_blocks)
        sha256_feed_64(H, final_blocks, 0, ByteLen(final_blocks))
        Local max_reg = width / 32
        For j = 1 To max_reg
          H[j] = _HEX(H[j])
        Next
        H = table_concat(H, "", 1, max_reg)
      EndIf
      Return(H)
    EndIf
  EndFunction

  If Not(IsNil(message))
    ;-- Actually perform calculations and return the SHA256 digest of a message
    Return(partial(message)())
  Else
    ;-- Return function for chunk-by-chunk loading
    ;-- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument
    Return(partial)
  EndIf

EndFunction

Local Function sha512ext(width, message)

  ;-- Create an instance (private objects for current calculation)
  Local length, tail, H_lo, H_hi = 0.0, "", CopyTable(sha2_H_ext512_lo[width]), Not(HEX64) And CopyTable(sha2_H_ext512_hi[width])
  
  Local Function partial(message_part)
    If Not(IsNil(message_part))
      If Not(IsNil(tail))
        length = length + ByteLen(message_part)
        Local offs = 0
        If tail <> "" And (ByteLen(tail) + ByteLen(message_part) >= 128)
          offs = 128 - ByteLen(tail)
          sha512_feed_128(H_lo, H_hi, tail..sub(message_part, 1, offs), 0, 128)
          tail = ""
        EndIf
        Local size = ByteLen(message_part) - offs
        Local size_tail = _MOD(size, 128)
        sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)
        tail = tail..sub(message_part, ByteLen(message_part) + 1 - size_tail)
        Return(partial)
      Else
        DebugPrompt("ERROR: Adding more chunks is not allowed after receiving the result", 2)
      EndIf
    Else
      If Not(IsNil(tail))
        Local final_blocks = {-999, tail, "\128", string_rep("\0", _MOD((-17-length), 128) + 9)}
        tail = Nil
        ;-- Assuming user data length is shorter than (2^53)-17 bytes
        ;-- 2^53 bytes = 2^56 bits, so "bit-counter" fits in 7 bytes
        length = length * (8 / 256^7)  ;-- convert "byte-counter" to "bit-counter" and move floating point to the left
        For j = 4 To 10
          length = Mod(length, 1) * 256
          final_blocks[j] = char(floor(length))
        Next
        final_blocks = table_concat(final_blocks)
   
        sha512_feed_128(H_lo, H_hi, final_blocks, 0, ByteLen(final_blocks))

        Local max_reg = ceil(width / 64)
        If Not(IsNil(HEX64))
          For j = 1 To max_reg
            H_lo[j] = HEX64(H_lo[j])
          Next
        Else
          For j = 1 To max_reg
            H_lo[j] = _HEX(H_hi[j]).._HEX(H_lo[j])
          Next
          H_hi = nil
        EndIf
        H_lo = sub(table_concat(H_lo, "", 1, max_reg), 1, width / 4)
      EndIf
      Return(H_lo)
    EndIf
  EndFunction

  If Not(IsNil(message))
    ;-- Actually perform calculations and return the SHA512 digest of a message
    Return(partial(message)())
  Else
    ;-- Return function for chunk-by-chunk loading
    ;-- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument
    Return(partial)
  EndIf

EndFunction

Local Function md5(message)
  ;-- Create an instance (private objects for current calculation)
  Local H, length, tail = CopyTable(md5_sha1_H), 0.0, ""
  For i = 1 To ListItems(H)
    If i > 4 Then H[i] = Nil
  Next
    

  Local Function partial(message_part)
    If Not(IsNil(message_part))
      If Not(IsNil(tail))
        length = length + ByteLen(message_part)
        Local offs = 0
        If tail <> "" And ByteLen(tail) + ByteLen(message_part) >= 64
          offs = 64 - ByteLen(tail)
          md5_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)
          tail = ""
        EndIf
        Local size = ByteLen(message_part) - offs
        Local size_tail = size % 64
        md5_feed_64(H, message_part, offs, size - size_tail)
        tail = tail..sub(message_part, ByteLen(message_part) + 1 - size_tail)
        Return(partial)
      Else
        DebugPrompt("ERROR: Adding more chunks is not allowed after receiving the result", 2)
      EndIf
    Else
      If Not(IsNil(tail))
        Local final_blocks = {-999, tail, "\128", string_rep("\0", _MOD((-9 - length), 64))}
        tail = Nil
        length = length * 8 ; -- convert "byte-counter" to "bit-counter"
        For j = 4 To 11
          Local low_byte = _MOD(length, 256)
          final_blocks[j] = char(low_byte)
          length = (length - low_byte) / 256
        Next
        final_blocks = table_concat(final_blocks)
        md5_feed_64(H, final_blocks, 0, ByteLen(final_blocks))
        For j = 1 To 4
          H[j] = _HEX(H[j])
        Next
        H = gsub(table_concat(H), "(..)(..)(..)(..)", "%4%3%2%1")
      EndIf
      Return(H)
    EndIf
  EndFunction

  If Not(IsNil(message))
    ;-- Actually perform calculations and return the MD5 digest of a message
    Return(partial(message)())
  Else
    ;-- Return function for chunk-by-chunk loading
    ;-- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument
    Return(partial)
  EndIf

EndFunction

Local Function sha1(message)

  ;-- Create an instance (private objects for current calculation)
  Local H, length, tail = CopyTable(md5_sha1_H), 0.0, ""

  Local Function partial(message_part)
    If Not(IsNil(message_part))
      If Not(IsNil(tail))
        length = length + ByteLen(message_part)
        Local offs = 0
        If tail <> "" And ByteLen(tail) + ByteLen(message_part) >= 64
          offs = 64 - ByteLen(tail)
          sha1_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)
          tail = ""
        EndIf
        Local size = ByteLen(message_part) - offs
        Local size_tail = _MOD(size, 64)
        sha1_feed_64(H, message_part, offs, size - size_tail)
        tail = tail..sub(message_part, ByteLen(message_part) + 1 - size_tail)
        Return(partial)
      Else
        DebugPrompt("ERROR: Adding more chunks is not allowed after receiving the result", 2)
      EndIf
    Else
      If Not(IsNil(tail))
        Local final_blocks = {-999, tail, "\128", string_rep("\0", _MOD((-9 - length), 64) + 1)}
        tail = nil
        ;-- Assuming user data length is shorter than (2^53)-9 bytes
        ;    -- 2^53 bytes = 2^56 bits, so "bit-counter" fits in 7 bytes
        length = length * (8 / 256^7) ; -- convert "byte-counter" to "bit-counter" and move decimal point to the left
        For j = 4 To 10
          length = Mod(length, 1)* 256
          final_blocks[j] = char(floor(length))
        Next
        final_blocks = table_concat(final_blocks)
        sha1_feed_64(H, final_blocks, 0, ByteLen(final_blocks))
        For j = 1 To 5
          H[j] = _HEX(H[j])
        Next
        H = table_concat(H)
      EndIf
      Return(H)
    EndIf
  EndFunction

  If Not(IsNil(message))
    ;-- Actually perform calculations and return the SHA-1 digest of a message
    Return(partial(message)())
  Else
    ;-- Return function for chunk-by-chunk loading
    ;-- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument
    Return(partial)
  EndIf

EndFunction

Local Function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)
  ;-- "block_size_in_bytes" is multiple of 8
  If type(digest_size_in_bytes) <> "number"
    ;  -- arguments in SHAKE are swapped:
    ;  --    NIST FIPS 202 defines SHAKE(message,num_bits)
    ;  --    this module   defines SHAKE(num_bytes,message)
    ;  -- it's easy to forget about this swap, hence the check
    DebugPrompt("ERROR: Argument 'digest_size_in_bytes' must be a number")
  EndIf

  ; -- Create an instance (private objects for current calculation)
  Local tail, lanes_lo, lanes_hi = "", create_array_of_lanes(), create_array_of_lanes()
;  Local tail, lanes_lo, lanes_hi = "", create_array_of_lanes(), hi_factor_keccak = 0 And create_array_of_lanes()

  Local result

;--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),
;--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)
;--~     initialize the state S to a string of b 0 bits.
;--~     absorb the input into the state: For each block Pi,
;--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,
;--~         XOR that with S and
;--~         apply the block permutation f to the result, yielding a new state S
;--~     initialize Z to be the empty string
;--~     while the length of Z is less than d:
;--~         append the first r bits of S to Z
;--~         if Z is still less than d bits long, apply f to S, yielding a new state S.
;--~     truncate Z to d bits

  Local Function partial(message_part)
    If Not(IsNil(message_part))
      If Not(IsNil(tail))
        Local offs = 0
        If tail <> "" And ByteLen(tail) + ByteLen(message_part) >= block_size_in_bytes
          offs = block_size_in_bytes - ByteLen(tail)
          keccak_feed(lanes_lo, lanes_hi, tail..sub(message_part, 1, offs), 0, block_size_in_bytes, block_size_in_bytes)
          tail = ""
        EndIf
        Local size = ByteLen(message_part) - offs
        Local size_tail = _MOD(size, block_size_in_bytes)
        keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)
        tail = tail..sub(message_part, ByteLen(message_part) + 1 - size_tail)
        Return(partial)
      Else
        DebugPrompt("ERROR: Adding more chunks is not allowed after receiving the result")
      EndIf
    Else
      If Not(IsNil(tail)) 
        ;-- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1
        Local gap_start = is_SHAKE and 31 or 6

        ;tail = tail .. (#tail + 1 == block_size_in_bytes and char(gap_start + 128) or char(gap_start)..string_rep("\0", (-2 - #tail) % block_size_in_bytes).."\128")
        tail = tail .. (ByteLen(tail) + 1 = block_size_in_bytes And char(gap_start + 128) Or char(gap_start)..string_rep("\0", _MOD((-2 - ByteLen(tail)), block_size_in_bytes)).."\128")
        keccak_feed(lanes_lo, lanes_hi, tail, 0, ByteLen(tail), block_size_in_bytes)
        tail = nil

        Local lanes_used = 0
        Local total_lanes = floor(block_size_in_bytes / 8)
        Local qwords = {}

        Local Function get_next_qwords_of_digest(qwords_qty)        
          ; -- returns not more than 'qwords_qty' qwords ('qwords_qty' might be non-integer)
          ; -- doesn't go across keccak-buffer boundary
          ; -- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords
          If lanes_used >= total_lanes
            keccak_feed(lanes_lo, lanes_hi, "\0\0\0\0\0\0\0\0", 0, 8, 8)
            lanes_used = 0
          EndIf
          qwords_qty = floor(math_min(qwords_qty, total_lanes - lanes_used))
          If hi_factor_keccak <> 0
            For j = 1 To qwords_qty
              qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])
            Next
          Else
            For j = 1 To qwords_qty
              qwords[j] = _HEX(lanes_hi[lanes_used + j]).._HEX(lanes_lo[lanes_used + j])
            Next
          EndIf
          lanes_used = lanes_used + qwords_qty
          Return(
                  gsub(table_concat(qwords, "", 1, qwords_qty), "(..)(..)(..)(..)(..)(..)(..)(..)", "%8%7%6%5%4%3%2%1"),
                  qwords_qty * 8)
        EndFunction

        Local parts = {} ;     -- digest parts
        Local last_part, last_part_size = "", 0

        Local Function get_next_part_of_digest(bytes_needed)
          ; -- returns 'bytes_needed' bytes, for arbitrary integer 'bytes_needed'
          bytes_needed = IIf(IsNil(bytes_needed), 1, bytes_needed)
          If bytes_needed <= last_part_size
            last_part_size = last_part_size - bytes_needed
            Local part_size_in_nibbles = bytes_needed * 2
            Local result = sub(last_part, 1, part_size_in_nibbles)
            last_part = sub(last_part, part_size_in_nibbles + 1)
            Return(result)
          EndIf
          Local parts_qty = 0
          If last_part_size > 0
            parts_qty = 1
            parts[parts_qty] = last_part
            bytes_needed = bytes_needed - last_part_size
          EndIf
          ;-- repeats until the length is enough
          While bytes_needed >= 8
            Local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)
            parts_qty = parts_qty + 1
            parts[parts_qty] = next_part
            bytes_needed = bytes_needed - next_part_size
          Wend
          If bytes_needed > 0
            last_part, last_part_size = get_next_qwords_of_digest(1)
            parts_qty = parts_qty + 1
            parts[parts_qty] = get_next_part_of_digest(bytes_needed)
          Else
            last_part, last_part_size = "", 0
          EndIf
          Return(table_concat(parts, "", 1, parts_qty))
        EndFunction

        If digest_size_in_bytes < 0
          result = get_next_part_of_digest

        Else
          result = get_next_part_of_digest(digest_size_in_bytes)

        EndIf

      EndIf
      
      Return(result)
    EndIf
  EndFunction

  If Not(IsNil(message))
    ;  -- Actually perform calculations and return the SHA3 digest of a message
    Return(partial(message)())
  Else
    ;  -- Return function for chunk-by-chunk loading
    ;  -- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument
    Return(partial)
  EndIf

EndFunction

Local hex2bin, bin2base64, base642bin
Block

  Function hex2bin(hex_string)
    Return((gsub(hex_string, "%x%x",
         Function (hh)
           Return(char(ToNumber(hh, 16)))
         EndFunction
      )))
  EndFunction

  Local base64_symbols = {
    ['+'] = 62, ['-'] = 62,  [62] = '+',
    ['/'] = 63, ['_'] = 63,  [63] = '/',
    ['='] = -1, ['.'] = -1,  [-1] = '='
   }
  Local symbol_index = 0
  For j, pair In IPairs({"AZ", "az", "09"})
    Local t1 = byte(pair)
    Local t2 = byte(pair, 2)
  
    For ascii = t1[0] To t2[0]
      Local ch = char(ascii)
      base64_symbols[ch] = symbol_index
      base64_symbols[symbol_index] = ch
      symbol_index = symbol_index + 1
    Next
  Next

  Function bin2base64(binary_string)
    Return(Base64Str(binary_string, False))

  EndFunction

  Function base642bin(base64_string)
    Return(Base64Str(base64_string, True))

  EndFunction

EndBlock

Local block_size_for_HMAC ; -- this table will be initialized at the end of the module

Local Function pad_and_xor(str, result_length, byte_for_xor)
  Local s = ""
  Local l = ByteLen(str)
  For Local p = 1 To l
    Local b = MidStr(str, p-1, 1, #ENCODING_ISO8859_1)
    b = _XOR_BYTE(ByteAsc(b), byte_for_xor)
    If b = 0
      s = s .. "\0"
    Else
      s = s .. Chr(b, #ENCODING_ISO8859_1)
    EndIf
  Next
  Return(s ..string_rep(char(byte_for_xor), result_length - ByteLen(str)))
EndFunction

Local Function hmac(hash_func, key, message)
  ; -- Create an instance (private objects for current calculation)
  Local block_size = block_size_for_HMAC[hash_func]
  If ByteLen(key) > block_size
    key = hex2bin(hash_func(key))
  EndIf
  
  Local append = hash_func()(pad_and_xor(key, block_size, 0x36))
  Local result

  Local Function partial(message_part)
    If IsNil(message_part)
      result = IIf(Not(IsNil(result)), result, hash_func(pad_and_xor(key, block_size, 0x5C)..hex2bin(append())))
      Return(result)
    ElseIf Not(IsNil(result))
      DebugPrint("ERROR:Adding more chunks is not allowed after receiving the result")
    Else
      append(message_part)
      Return(partial)
    EndIf
  EndFunction

   If Not(IsNil(message))
    ;  -- Actually perform calculations and return the HMAC of a message
    Return(partial(message)())
  Else
    ;  -- Return function for chunk-by-chunk loading of a message
    ;  -- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument
    Return(partial)
  EndIf

EndFunction

Local sha = {
  md5        = md5,                                                                                                                   ; -- MD5
  sha1       = sha1,                                                                                                                  ; -- SHA-1
  ; -- SHA2 hash functions:
  sha224     = Function(message)                        Return(sha256ext(224, message))                                           EndFunction, ;-- SHA-224
  sha256     = Function(message)                        Return(sha256ext(256, message))                                           EndFunction, ;-- SHA-256
  sha512_224 = Function(message)                        Return(sha512ext(224, message))                                           EndFunction, ;-- SHA-512/224
  sha512_256 = Function(message)                        Return(sha512ext(256, message))                                           EndFunction, ;-- SHA-512/256
  sha384     = Function(message)                        Return(sha512ext(384, message))                                           EndFunction, ;-- SHA-384
  sha512     = Function(message)                        Return(sha512ext(512, message))                                           EndFunction, ;-- SHA-512
  ; -- SHA3 hash functions :
  sha3_224   = Function(message)                        Return(keccak((1600 - 2 * 224) / 8, 224 / 8, false, message))             EndFunction, ;-- SHA3-224
  sha3_256   = Function(message)                        Return(keccak((1600 - 2 * 256) / 8, 256 / 8, false, message))             EndFunction, ;-- SHA3-256
  sha3_384   = Function(message)                        Return(keccak((1600 - 2 * 384) / 8, 384 / 8, false, message))             EndFunction, ;-- SHA3-384
  sha3_512   = Function(message)                        Return(keccak((1600 - 2 * 512) / 8, 512 / 8, false, message))             EndFunction, ;-- SHA3-512
  shake128   = Function(digest_size_in_bytes, message)  Return(keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message)) EndFunction, ;-- SHAKE128
  shake256   = Function(digest_size_in_bytes, message)  Return(keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message)) EndFunction, ;-- SHAKE256
  ; -- misc utilities:
  hmac       = hmac,       ; -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*
  hex2bin    = hex2bin,    ; -- converts hexadecimal representation to binary string
  base642bin = base642bin, ; -- converts base64 representation to binary string
  bin2base64 = bin2base64, ; -- converts binary string to base64 representation
}


block_size_for_HMAC = {
   [sha.md5]        = 64,
   [sha.sha1]       = 64,
   [sha.sha224]     = 64,
   [sha.sha256]     = 64,
   [sha.sha512_224] = 128,
   [sha.sha512_256] = 128,
   [sha.sha384]     = 128,
   [sha.sha512]     = 128,
   [sha.sha3_224]   = (1600 - 2 * 224) / 8,
   [sha.sha3_256]   = (1600 - 2 * 256) / 8,
   [sha.sha3_384]   = (1600 - 2 * 384) / 8,
   [sha.sha3_512]   = (1600 - 2 * 512) / 8,
}



Function test_hash_lib()
  Function test_sha256()
    DebugPrint("=== sha256 ===")
    Local sha256 = sha.sha256

    ; -- some test strings
    DebugPrint("  Some tests strings...")
    Assert(sha256("abc") = "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad")
    Assert(sha256("123456") = "8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92")
    Assert(sha256("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq") = "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1")
    Assert(sha256("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu") = "cf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1")
    Assert(sha256("The quick brown fox jumps over the lazy dog") = "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")
    Assert(sha256("The quick brown fox jumps over the lazy cog") = "e4c4d8f3bf76b692de791a173e05321150f7a345b46484fe427f6acc7ecc81be")

    ;-- chunk-by-chunk loading:   sha256("string") == sha256()("st")("ri")("ng")()
    DebugPrint("  Chunk-by-chunk loading...")
    Local append_next_chunk = sha256() ; -- create a private closure for calculating digest of single string
    append_next_chunk("The quick brown fox")
    append_next_chunk(" jumps ")
    append_next_chunk("")              ; -- chunk may be an empty string 
    append_next_chunk("over the lazy dog")
    Assert(append_next_chunk() = "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")  ; -- invocation without an argument means "give me the result"
    Assert(append_next_chunk() = "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")  ; -- you can ask the same result multiple times if needed

    ; -- one-liner is possible due to "append_next_chunk(chunk)" returns the function "append_next_chunk"
    DebugPrint("    One liner test...")
    Assert(sha256()("The quick brown fox")(" jumps ")("")("over the lazy dog")() = "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")

    ; -- empty string
    DebugPrint("  Empty string...")
    Assert(sha256("") = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")
    Assert(sha256()() = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")

    ; -- two parallel computations don't interfere with each other
    DebugPrint("  Two parallel computations...")
    Local chunk_for_digits = sha256()
    chunk_for_digits("123")
    Local chunk_for_fox = sha256()
    chunk_for_fox("The quick brown fox jumps ")
    chunk_for_digits("45")
    chunk_for_fox("over the lazy dog")
    chunk_for_digits("6")
    Assert(chunk_for_digits() = "8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92")
    Assert(chunk_for_fox() = "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")

    ; -- "00...0\n"
    DebugPrint("  zeros...")
    For i, dgst In Pairs({  ; -- from 50 to 70 zeroes
      [50] = "9660acb8046abf46cf27280e61abd174ebac98ad6855e093772b78df85523129",
      [51] = "31e1c552b357ace9bcb924691799a3c0d3aa10d8b428d9de28a278e3c79ecb7b",
      [52] = "0be5c4bcb6f47e30c13515594dbef4faa3a6485af67c177179fee8b33cd4f2a0",
      [53] = "d368c7f6038c1743bdbfe6a9c3a72d4e6916aa219ed8d559766c9e8f9845f3b8",
      [54] = "7080a4aa6ff030ae152fe610a62ee29464f92afeb176474551a69d35aab154a0",
      [55] = "149c1cda81fa9359c0c2a5e405ca972986f1d53e05f6282871dd1581046b3f44",
      [56] = "eb2d4d41948ce546c8adff07ee97342070c5b89789f616a33efe52c7d3ec73d4",
      [57] = "c831db596ccbbf248023461b1c05d3ae084bcc79bcb2626c5ec179fb34371f2a",
      [58] = "1345b8a930737b1069bbf9b891ce095850f6cdba6e25874ea526a2ccb611fe46",
      [59] = "380ad21e466885fae080ceeada75ac04944687e626e161c0b24e91af3eec2def",
      [60] = "b9ab06fa30ef8531c5eee11651aa86f8279a245e0a3c29bf6228c59475cc610a",
      [61] = "bcc187de6605d9e11a0cc6edf02b67fb651fe1779ec59438788093d8e376c07c",
      [62] = "ae0b3681157b83b34de8591d2453915e40c3105ae79434e241d82d4035218e01",
      [63] = "68a27b4735f6806fb5983c1805a23797aa93ea06e0ebcb6daada2ea1ab5a05af",
      [64] = "827d096d92f3deeaa0e8070d79f45beb176768e57a958a1cd325f5f4b754b048",
      [65] = "6c7bd8ec0fe9b4e05a2d27dd5e41a8687a9716a2e8926bdfa141266b12942ec1",
      [66] = "2f4b4c41017a2ddd1cc8cd75478a82e9452e445d4242f09782535376d6f4ba50",
      [67] = "b777b86e005807a446ead00986fcbf3bdd6c022524deabf017eeb3f0c30b6eed",
      [68] = "777da331f60c793f582e4ca33223778218ddfd241981f15be5886171fb8301b5",
      [69] = "06ed0c4cbf7d2b38de5f01eab2d2cd552d9cb87f97b714b96bb7a9d1b6117c6d",
      [70] = "e82223344d5f3c024514cfbe6d478b5df98bb878f34d7a07e7b064fa7fa91946"
      })
      Assert(sha256(RepeatStr(0, i).."\n") = dgst)
    Next

    ; -- "aa...a"
    DebugPrint("  aa...a...")
    Assert(sha256(RepeatStr("a", 55)) = "9f4390f8d30c2dd92ec9f095b65e2b9ae9b0a925a5258e241c9f1e910f734318")
    Assert(sha256(RepeatStr("a", 56)) = "b35439a4ac6f0948b6d6f9e3c6af0f5f590ce20f1bde7090ef7970686ec6738a")

    ; -- negative byte values
    DebugPrint("  Negative byte values...")
    Assert(sha256(RepeatStr("\255", 1e3)) = "b4f73dff046400b76728ab32619e3d89e00132653725f660c62ab9fca975b372")

    ; -- "aa...a\n" in "chunk-by-chunk" mode
    DebugPrint("  aa...a... chunk-by-chunk mode")
    Local next_chunk = sha256()
    For i = 1 To 65
      next_chunk("a")
    Next
    next_chunk("\n")
    Assert(next_chunk() = "574883a9977284a46845620eaa55c3fa8209eaa3ebffe44774b6eb2dba2cb325")
    
    ; -- "aa...a\n" in "whole-string" mode
    DebugPrint("  aa...a... as whole string")
    Assert(sha256(RepeatStr("a", 65).."\n") = "574883a9977284a46845620eaa55c3fa8209eaa3ebffe44774b6eb2dba2cb325")

  
    Local function split_and_calculate_sha256(s, len) ; -- split string s in chunks of length len
      Local next_chunk = sha256()
      For idx = 1 To ByteLen(s) Step len
        next_chunk(sub(s, idx, idx + len - 1))
      Next
      Return(next_chunk())
    EndFunction
    ; -- "00...0\n00...0\n...00...0\n" (80 lines of 80 zeroes each) in chunk-by-chunk mode with different chunk lengths
    DebugPrint("  80 lines of 80 zeroes each) in chunk-by-chunk mode")
    Local s = RepeatStr((RepeatStr("0", 80).."\n"), 80)
    Assert(split_and_calculate_sha256(s, 1)   = "736c7a8b17e2cfd44a3267a844db1a8a3e8988d739e3e95b8dd32678fb599139")
    Assert(split_and_calculate_sha256(s, 2)   = "736c7a8b17e2cfd44a3267a844db1a8a3e8988d739e3e95b8dd32678fb599139")
    Assert(split_and_calculate_sha256(s, 7)   = "736c7a8b17e2cfd44a3267a844db1a8a3e8988d739e3e95b8dd32678fb599139")
    Assert(split_and_calculate_sha256(s, 70)  = "736c7a8b17e2cfd44a3267a844db1a8a3e8988d739e3e95b8dd32678fb599139")
    Assert(split_and_calculate_sha256(s, 1e6) = "736c7a8b17e2cfd44a3267a844db1a8a3e8988d739e3e95b8dd32678fb599139")

  EndFunction
  
  Local Function test_sha512()

    DebugPrint("=== sha512 ===")
    Local sha512 = sha.sha512

    DebugPrint("  Some test strings...")
    Assert(sha512("abc") = "ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f")
    Assert(sha512("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu") = "8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909")

    ; -- "aa...a"
    DebugPrint("  1-140 a letters")
    For i, dgst In IPairs({ ; -- from 1 to 140 letters "a"
      [001-1] = "1f40fc92da241694750979ee6cf582f2d5d7d28e18335de05abc54d0560e0f5302860c652bf08d560252aa5e74210546f369fbbbce8c12cfc7957b2652fe9a75",
      [002-1] = "f6c5600ed1dbdcfdf829081f5417dccbbd2b9288e0b427e65c8cf67e274b69009cd142475e15304f599f429f260a661b5df4de26746459a3cef7f32006e5d1c1",
      [003-1] = "d6f644b19812e97b5d871658d6d3400ecd4787faeb9b8990c1e7608288664be77257104a58d033bcf1a0e0945ff06468ebe53e2dff36e248424c7273117dac09",
      [004-1] = "1b86355f13a7f0b90c8b6053c0254399994dfbb3843e08d603e292ca13b8f672ed5e58791c10f3e36daec9699cc2fbdc88b4fe116efa7fce016938b787043818",
      [005-1] = "f368a29b71bd201a7ef78b5df88b1361fbe83f959756d33793837a5d7b2eaf660f2f6c7e2fbace01965683c4cfafded3ff28aab34e329aa79bc81e7703f68b86",
      [006-1] = "7a9b2a35095dcdfedfdf0ef810310b409e38c92c20cbd51088ea5e4bc4873bdacfeb29f14b7f2ed033d87fad00036da83d5c597a7e7429bc70cec378db4de6a6",
      [007-1] = "d1ff70451d1f0b94f551461c5ca239e498f571add4542c381e3eef84eac24aea6d12f8333ef4a05847e205ef4bb094921314364e7648176f567863d982042a85",
      [008-1] = "f74f2603939a53656948480ce71f1ce466685b6654fd22c61c1f2ce4e2c96d1cd02d162b560c4beaf1ae45f3471dc5cbc1ce040701c0b5c38457988aa00fe97f",
      [009-1] = "507294e03fdbc784dc3f575706c3ce53b3c4c37065e89ddd6b6de8bd2be655e15412e27695d32d2d6a3a0eaabe36ebddde78af0122a65ec41128c98c6fd30554",
      [010-1] = "4714870aff6c97ca09d135834fdb58a6389a50c11fef8ec4afef466fb60a23ac6b7a9c92658f14df4993d6b40a4e4d8424196afc347e97640d68de61e1cf14b0",
      [011-1] = "2d5be0f423fee59bf2149f996e72d9f5f8df90540a7d23b68c0d0d9a9a32d2c144891ca8fe4a3c713cb6eb2991578541dad291ba623dbd7107c6a891ba00bcc8",
      [012-1] = "a88ac22ca41e71e252c1f0d925de1ec174346e097c695e948d23016ab54cf21da6f0b0490ffa752bcc4893afc0c2caa64307705d1996f2959a3e03dc420c68cf",
      [013-1] = "b0b8828df9473f2763f9a48b0a9683451e98155436c2eff64c628fedbba0cca2360312271f3971f2969b1f828b1bb8251d3a43e12361824aca14f9a9affe2171",
      [014-1] = "831ce89c92608efda86cdf89d36e855bc73c5d17b2162c0013c14a2676ef4794dc53de6a54c1e3fb782acef5dd1192d36d0ab7fa88262cf0f6a16950e44a828c",
      [015-1] = "0b6f7fb0679a1ef009d5c8c70551d3b7013a5881b41ec2d597c3cf22e6aa13a1cf9a925b7a012feb67956c83b91cc32bef1de4cdbc6b2ff0cffbba319b54d15e",
      [016-1] = "987d0fc93db6a73fdb16493690fb42455c7c6fbafe9a276965424b12afad3512fb808d902faa8a019d639dc5ad07c235805e08f396147cf435913cfed501f65a",
      [017-1] = "06ef0364617146f6200c2cbc4280202226d701c2961940f57e7b60677587c66087f23bbcffa0de8692221f9434ac9a21e6df6428377cd145e1a456e2359d2cf6",
      [018-1] = "10dbd292472d3ff7279f3dac7fdb83c296bd61cbe80b0e26fbc14f871fd9771180d83879e812ec9841ba15a110e84a589c0eedfc14427c23ba56fa4fb7773de0",
      [019-1] = "1d383178e64d7071e749b2d560a22abc97e6514c31e800b5cc12c6f72ad43a9a0c4ce7db246219f3dea09afae6044a484de203148cb55f1057ee37b9420073bb",
      [020-1] = "d87a10a0bee363dcdf764831e807df5ee5500483c09056b38f854606f9e665566264b15af9fee8f9b84f3a7b6ddb67b92996ef790d10e899ba0758d5ab650caf",
      [021-1] = "1f60925cd5271a8ec9eb49ea4bf187f6a7dbc22eeb0e2dbc89d8381d0e73dea5bff5375a6db7e49fc427cb4fdf9f7ece577037adf91decfc38f303b1cb79ad44",
      [022-1] = "0ff3b2ffbda4cf938263e9449735618103a4d6a0cdeeda57367f6377d23849c3dce6851377f8f1b3d2ce3ff1dd6de0d64920d7790994782b4a8e2697e31f1900",
      [023-1] = "c6020ac00b701699227ccc9355156da0ad1d521ada5949cc89dd00661725be08fea4a2519ceb1e50acdd16e7127783f7ed5bfabe5238ce0da7ad2b4174c5509a",
      [024-1] = "e37ff6da226042c6fdd066c20f00e0d09c4f4dea104d8ea1fc513496ef24a0e17cd4bfb2e95781329a45d3885ca0e20f88e453dc9a4c4dc2acd0be756e3356b8",
      [025-1] = "4d272d73d4000f885ad1be048b7c7f92c2a8e5a01f30a96ed82849223606ad639f73155c85a128fbd2c26d3de30fb207e57b9f7ff21bfc79e0d7f0e2fb5189dc",
      [026-1] = "90cce547b76967676972c60e83944ffdc143078b6b40c722a0f2ac90d78eed0057843213076a9a7df528d0c0ebf3c00a91ae1c37f8850173fa2c03c41b6168ea",
      [027-1] = "4cea8c7ef657f9177c286081f8f016adae91a131a496e939ac86060e691afba57accc08ddbc423eb9d0817725faad9554c60f314929f30e881871e8782228918",
      [028-1] = "24077df741cb7ba88537d62c55fbff3ea81b603c31e6fd0d2e5d28e1a505f6192d5b2c1f98011152fef2c75901f66d489c045a4a3f98705c2b244c004f1579d4",
      [029-1] = "2af97e464526c024ef466db4616559919b769b350b7f6830ecfa5ffdeacd6eb570daf0ed25c0c56b194119f15247f63f5b94b54e01283b4b7a832586acac9e09",
      [030-1] = "abd9c33f8c791b27dd614e80ad77f1ff33c2621663b4dcbe5a88417a8b95b8d6788a9320678b589aa5b405897b2113523df1defa304953ea2ae1a229f2736450",
      [031-1] = "ad9e7ae1f68786c33ca713d4632b29ebcc9c9c040fc176ead8acb395a14c08324e824f7531f6a50ba0d4a17de958a08e54c9597dcc30781e22c0d953d06f9f4d",
      [032-1] = "020089a47cb0761c222c323aec2bdecdaa7a0d0ec094cda8c5755ba26844453c25b37e4bc98aab8adc55c9da75bcd83af62905d62e9044a5d64cd93d93b54b34",
      [033-1] = "d578a2d3fab982fbc7f1fa20630713c5a2a2cd9654a53822978d3efd2becc2a02e1fa1391dd11e139d1489aba688367ea9286e2a9ba8ef67009c80df81998614",
      [034-1] = "c1de14e1a09b03c688bd568ff4b4fa086baed2181d0d99a219fb937484ba67f093efe36966b0ea5209dadb6ef4f67c2d1f753d49c083a6241d2ab4557509404e",
      [035-1] = "cbb50e7e8a14cb9df08642609b6d737302d78cdcff74e1f53e895ae4a7cb093a571364dbbc2797962f54366ef65ead1c41a44ffe2ab0d56b7ae01e99a7a4e6fb",
      [036-1] = "85a564722dbefd268ed2e2e70fb377306c207a9c7edb634adcd79b8829aaad700c3a26cce44eba99aff46c4349f5e5056a87fcd2b63dd08b8b7b1f2f3ea06d6b",
      [037-1] = "ae77859a42c40e3973aa42bc8fbe8713444f65173580507d7c4bcc7c85d7f8c93204f433d506e912504ea37c766af17e649bdf6c8356f6e8e65bf4e9321987cb",
      [038-1] = "5b7c791e8018b14752ca7b91386d3ddbd3f9307a69ca71d977e274171aa5cae0b1a03960e842ca05fc0b95205a243fc8b28c36e4dd60ff000a47fb63547e6a0c",
      [039-1] = "f140bd9a11c309eb9da6ae1c8360cf2bc952a41a9ff228c066c0811df508313f59f1b6e6ffc6d14ef967f477c69463974aefd78d1c1dec9d8d35ff0c81dc29e8",
      [040-1] = "e411795f8b2a38c99a7b86c888f84c9b26d0f47f2c086d71a2c9282caf6a898820e2c1f3dc1fa45b20178da40f6cb7e4479d3d7155845ed7a4b8698b398f3d0c",
      [041-1] = "9178f65d74628c56ce3ace5b9ae7ecb84fc8a840ae33367a9c5534e6556301dc4fea4927d82289483496c39b929afb4a4ea92ded82c02057a7b8029828d8fb8d",
      [042-1] = "e11e1d056266f561bf3a9dede38228700e59971b3be992fea66a687887441976d8b29193707211dfb94dd1f7918473c3e99ff48a7c91068a1aaf7054febb9e2d",
      [043-1] = "acbaf243155ab6ca5f44c13061757fa060acbc5cf43d996b4f47209c22bf70c29af8dbc5c0a68ca45e42142db1540d2db70f6f27a917a3019dc92dadd0f639d6",
      [044-1] = "647b6deadb5aeb56e4087414fe2a76d6f57083dd6303a19e152445d108dc2bcd17926981d500b19b913b36a3b343b2e6781c805c1897664a218a2cfecc6a5238",
      [045-1] = "3ca97cdefcc384485ec2b6bebffe63d98f5675132a8b43d1f38bad4ff1982264fc4876ec637e918f855d855945b9b84eb82386bc6fc1e92695ec623001f8ddd1",
      [046-1] = "7b549433b4ef39abb90dcd3eb90c63562b7f3daa056670b2f712ebb7e9e78adfe7423e4b39810c1109fb640e84d32047468b155fe342d13e7f4d7ee019fa5922",
      [047-1] = "ec1d753e2280b8136b686ec81b03b3f8a7f98152868e3a68f0a2c456082c2faaa93c39ad573a6d21f4a3350df602249dc89ad28620d27ecc1d9e1f258badcd04",
      [048-1] = "bd582a787a21036df7049d501879977625601527d7ddd6f707463cb8b3839fbedbe233b8e69f1696d0e82b168d3491a3dbb6005b6224c198601dafbd50e14365",
      [049-1] = "4b4ff3bc763a976c16afdd8082efc7a5c98d60342f0ed5a654f567dacbc6414833e60ed1d6770bd42638fdae605c69be0219532125a186609f0825376ab59e45",
      [050-1] = "bdba173e58132092b0aa67ea5080f247e5b3710630a789c519b311f3848588f0bac8db3091ff8fd16875601636bef625e43b3d82cb51eb6693cdd1b2a5c872b8",
      [051-1] = "78a0eb5d7c0b05284056e1f19cbb42a99470bc81de4f9bc48708d28c5a877626e69167c58d4e840a7aa699bc6dddd972564d84ea502b41d83878e98e68f83c81",
      [052-1] = "a45021322d3f30747b3ceb7c1b1975ac4698984be76915f82cdeefe769f115d9dc5c70549e897b0ab8d5d61fc9e73ad1f7f49db39bb4e1298ac833d290eb1d04",
      [053-1] = "0b08accaae7044e54074fdcb7404a10c0703144d4499a644d9cfc60f973dc27dcdc65ac31750f7407ba96d025fb699e64ddcd1acd0dabafeeafccb5733225d3b",
      [054-1] = "07a2200290a2b7423a94f71892554b17196e2301e2e446ce09f65abcb45523268274128038925489671af9b899747b80e35a0a1b8613ecfb44e6be3152a2fd93",
      [055-1] = "b0220c772cbf6c1822e2cb38a437d0e1d58772417a4bbb21c961364f8b6143e05aa6316dca8d1d7b19e16448419076395f6086cb55101fbd6d5497b148e1745f",
      [056-1] = "962b64aae357d2a4fee3ded8b539bdc9d325081822b0bfc55583133aab44f18bafe11d72a7ae16c79ce2ba620ae2242d5144809161945f1367f41b3972e26e04",
      [057-1] = "d3115798e872fc1ca6b276368e8ea0926daec6ab1f8f08297e4348ff5f5fe4c6e5205413271babafd4929b070754bc5800e5db44790666ec4e2f6ac52a17e163",
      [058-1] = "2282084c042e92d7ba1a9e1ee5527762e91c4ffee7a8676c4a4a0facefad352bed2d3c322368cfe813186084c5386e9f22f803dfe0a1b424cab3e0a95a6dc3f9",
      [059-1] = "fd4eaf2071e8d9cf36688c3be714f5e363a5b4932f509914c613d1b8987d188e82cdd12b6ab07ea2f676fad1789275ef37253260a817a61079bc0ea567ee094a",
      [060-1] = "5ac08e89d884de3f086c60e8f36e754cf0ae9be2f018a87b7f71b15c81356410077eaa075010eb48959783ba490dc7c9fec53573848d8929bd5fc0574552f58f",
      [061-1] = "0202004b03bf7be513c96ef3fa6e48fce6e02f858d3bd95edba5adbdce60b2d7a4aa8700de15fc421b5e6847d8fb8be1bd24acd16314cfd94f0fa69ff6d637b4",
      [062-1] = "9814d48ae1bfd731b32f0a829f20507ec9bd6b77609053718f7e2053b53c7a264bbab6a96d3d54a7f9a736570d11b1f99afb1735149f43cfee9b6f87886d3ff6",
      [063-1] = "c1b0f5c6d3b03dfe4a2602e67242f54e344090b66e01100a469b129f583f016c7e27dddeaa438393dcc7ec54b0b57c9ba7af007f9b56db5f6fb677d972a31362",
      [064-1] = "01d35c10c6c38c2dcf48f7eebb3235fb5ad74a65ec4cd016e2354c637a8fb49b695ef3c1d6f7ae4cd74d78cc9c9bcac9d4f23a73019998a7f73038a5c9b2dbde",
      [065-1] = "b83086cd8494e55708ad7ecd82dfb4bca1bda61ecbb7caf0c68967902e709345e5d8305eb7ac0d588afc6cbb75161aa9c8c7e0ea986bd833dafe5e1ccd37345a",
      [066-1] = "f2f1cb2b1da21f7df43034baf8ec6bc992a46a022a40f81339240fdae572dbdf34fcf26e97cabc0e001c0aa65607b45585d107c48d676d6e2f389fd801d1fed7",
      [067-1] = "1b049c5022acb0a6f886cb607629db83dee7ee8f623f8f0fcf352b8f5052036cc7e992e9f79bc424173abb07df8ccfb058f13cfe2a14925a1bb67f4447dd8929",
      [068-1] = "6c450032dd6b928bdb327b9892d15808163d314aeff37089380ca01ee4b1c8db739f71de29446c385fc8e0f12482ccb04ca1572e243affc7d77ed7bbc083be0d",
      [069-1] = "73fa82cfc129fb937094b53346e04ff29e44c67250f6952b63ef561bc7cc1169fd94368a252ae408f496c17684145d65cd46ec9c5a03eb59ecc35f6a1d2fc159",
      [070-1] = "d7ef283e6194befc2498bbced7f58bdf60cfcf10011fc5817b69cb13d63725017aa1e632ea3c609f6a5eb8a057ddb82953538f3e2a738262a11ddcd47f13752d",
      [071-1] = "216d4ffba1e94e8f281b06feb558346eeb0ae567c0a1d0c56ba2df704f45b2a6e6d91f97c5c00ebbcdfeb14b438bd9e56f2eb36ca64d22392520f3496f28fef5",
      [072-1] = "7e076f0892677d21072e99258203151146d4bc78ad6ed68edc939ba080c473ab66b10d38834e33abde71830dbd8529d895c7ea5f5773f1457d7c71bc3824b7c8",
      [073-1] = "1a3d403b46c595edfb71d10b4cb9e1b9ce4e44e28db6ba2a0334195816b85e6eba147bc6160864a0fe28166f99148476893a031a38a814e7136497296865f3c9",
      [074-1] = "4c4c8dcd6ba88f47a51df4dabdf227c335d70d5f4941b76e698536693e53c50241ef0264ea6f6dc5527485ddbe7a76900405158e32fef5ed184919943148da67",
      [075-1] = "8ea2d14c839946461666ab0a5966a10886e29d0a890104b123bb94d0af9011d8a961681fb95df98d00d5d351985f61f2e2eba2d91fd8032566b856d8408a09b0",
      [076-1] = "c642ba36e76cc1660c342d163fb32e4be8482072e641dd6b3662c447ecbc24f1b5e16ad4b83eed093c6f5999f1b2a0086fc23526cef9241a5a052c720bb5afde",
      [077-1] = "b9451e8c39c4276c2192939d49cbcb2b85a048e4f38bb5d3282e24c417de893ac2ff0acdef20036ed4deddbb526f992cd56f992aaba93d4edd3a628a4e53c811",
      [078-1] = "9a8c06cf6123391e9ee4d2441b7e534fc9551c242fb2b96fad45a7210edc010c36704b9ca1a07e935e6ff1413768e2f27726b213b16961633341ea82d75c5df3",
      [079-1] = "54b998867e8ac0d3eebcbf2252c107ad6dc5b557db5b7cb65a147475db99831011878784a62678a6fada687705ef68d048047f05b51db9c09168c4a7ad877036",
      [080-1] = "cb8d0d18db405d9d964ab61d1a5c00024df3805a329bf1500bec74d3ec1f1d0574da0b86153c9d8e317603bdb09e46d54d44551992a2464f0335a8398a2f2aee",
      [081-1] = "2fe6df89dcac80c7a03c2bc39633c12ae2898019117aacf77e490fa54cb8deb34a0d29ce778ee4f674831921853a15b541773486d5ac785163744e6d24ba388d",
      [082-1] = "c3e410354f6f890d0f3027805da471340f91db2a858501059124d3175eb7d637ca3637f7f95bafde0d74d026be7bf086e48931e299d68edc43e0a7ac4eac75c4",
      [083-1] = "107068fb436d658c0a96157316af41d323e582ea9c81146933ead563bf2c2a05b2c77ceeef57c01cd09ec28f6507238e930b1b7241d731f83194440f9256e5a6",
      [084-1] = "62b5337f5be290d028dc41dde08682ed7b0a7a842eae36dc6f7220e220012aeca98b2dac28325d1f78beef84352689c07c3a45f549e98ba908b010abceca9978",
      [085-1] = "6b6f3ac1316d9e8d1505ad163b70077df1df92568139721b32c23e5d84dc2fd742a4bad56bf0efacb3f3e63bbfb08a829b16df8cc1799eb199cd5d56be2b9d52",
      [086-1] = "bf8ed43d3aeebeb9b00d91013fbbb463b2f4b13e7ffc42741aeb9f0190a91b0401bb4fac68cc009d314287876c54d2f18891e6eee86fbe7125171559be6a03d7",
      [087-1] = "056ffe9a8b3a346abb92cf36efb74417748a044c4ca07f94e7bb076eeafa67073a85fcc1b17e7953138f304bbea7d0592e910e55b489e22c9015dc4e04ba76dc",
      [088-1] = "a945652aabf28d5ed6bb284a35fd4296a9a0ddebc81bf59991759ecaa7fb95a59628cf1ae75c88177fa3993e0cd0f138a807cdc01d17ca3922817ad1dc1c39e7",
      [089-1] = "bb4ec00ac4a82ed71af3936559c5940582218da063554c6f3efbb6d67cc808a2d6dbf088d0f371a4a1259efb1f1edeefa8093cab25551519d7ac6142711e50fe",
      [090-1] = "3a60fa8bede0f822c5dea75eff151ed5841d11b301c474a13571aff2dd0e216b4bc072b9ce409a70c6e6ff35bcae2f0950880d943f95775dd8f54d94b12d47c3",
      [091-1] = "bed8ac47aef0271fe40227247ddcdfd6b4885effeba3042f34b6fd525ab56cbdf72050cb71b1d42ae0ee1c548b36668b9297279d661380dffa39e66aa2959f99",
      [092-1] = "dfecce5852f67e858304fc5dc0c15cb29e28c69af4e2c117d333ea46d2ef2b0379a983507bc16e827b86c2433404159b759de91eb9ae975f338bacf38ad20371",
      [093-1] = "51585d172675d427009ea1658ac2a4d67a600e65034cb7f8eb34a39add704b67ae0a2798b7d7e7a16ee0f6902a165a0646cd9fe1cc777a07c6bfa14028c8eec8",
      [094-1] = "9e4246d4d3725a67a909dd1a4f06c627627942c0bb31eb4c614cab842e6bfb9faa7e8938575a2402832ac353a6fb47f4918b31d754eb9764e714f6925462b54e",
      [095-1] = "89e0446c3ff5a04b6d707ef43a77e2b349791f402930dbdb74bbab73d5215e294146ba7bd2fa269aee38564ef11a9ccaf5278f9e82687126dcf20d481d470617",
      [096-1] = "39ba3c74b23cb7deffb5d59624e320c08692637057daaaeea4d847e1d3b6a2ce6895ff3c609d57da490484b030ed231d5bdfafcfe264bd3d91cddb39c2d036ab",
      [097-1] = "db3a1fb5909f50e02e1626616247de6867e9e332d0eeef4650367cf0058f4764eb4a3869d3931b5ef6fc7a044a868b5fa894462df15c3954e88cd70c9a1de1b2",
      [098-1] = "86497b815f64702e2ac6aca1f1d16f7159b4f0b34f6e92a41e632982a7291465957e0ef171042b9630bb66c6e35051613f99bdc95c371eeb46bff8c897eba6e9",
      [099-1] = "21883a9b2ffa353c93fea49ea8b92be22797e6e8b360ebac8ed894b702766458a825adf67d9561d6758f5f9cc3aec7a4b2e4464a08e6959029dbc0b2f3fc6105",
      [100-1] = "70ff99fd241905992cc3fff2f6e3f562c8719d689bfe0e53cbc75e53286d82d8767aed0959b8c63aadf55b5730babee75ea082e88414700d7507b988c44c47bc",
      [101-1] = "2327e3b2946432dd2f4bce390ca652ec5e90f44fced0e921f612cf6d594cfc5e21b56e30a30dc0157e2c37a59cd37951f20cb9e2bc2d815a2676c01c2f827d51",
      [102-1] = "ec90d76ee1a1643126f53609a2721ad4a130c57d4dd0416a5d1b0bc43419ed6b3b0e82e0ff5eb76e94accfacb8bf72d7c92b622a0842d9a5b8b6e40fa2fc5231",
      [103-1] = "48e257ba5ef0c4b0b9769d26d5990d87f058430e368802c1f9a47195a6fa23ede9bbadc4c46ef2a8480cbfa0ced25dad522ca1752a66d5b43a72486f82c7b934",
      [104-1] = "e4f39bcd76fe94bfa84b31b0b9f3d2fe065b1e01ff2c3c0cd6f26b942f3c73a35031b9ecb4d82418a52892dabb459b27f0ba04af5e90636edf0b2caaa2d7906a",
      [105-1] = "3b6dd73c9552f2381107bf206b49c7967fdc5f5011d877d9c576bb4da6d74fbbabf46a1105242d7c645978e54c0b44adaf06d9f7aa4703e8a58829f6d87c5168",
      [106-1] = "470edb01e9dc9db187acdc9fa594e35b40831f9ddf76309d4a99a7aef1f0d9f79b5a4c9a22a38aeca3a1c2d6ceaeb603899577a30643a97872717c025a9a4fdc",
      [107-1] = "8cfcdd655481cca50730fe51ee985e9b51946f1345cb6a1801e5e0ed64ef979f431d5a7c3bd2a479d6d82e354210741956d194ee0febbc132b35907f4e2be32f",
      [108-1] = "a53d93726f1ba688a57267326473eceddc4ccf992d5c53429ca3edd4b122b4fe0b0568887d65c220cbac93fc4f612f97a09eb95e9f903409c78a22eee4fa1781",
      [109-1] = "0cda6b04d9466bb7f3995c16732e1347f29c23a64fe0b085fadba0995644cc5aa71587423c274c10e09518310c5f866cfaceb229fabb574219f12182eb114182",
      [110-1] = "c825949632e509824543f7eaf159fb6041722fce3c1cdcbb613b3d37ff107c519417baac32f8e74fe29d7f4823bf6886956603dca5354a6ed6e4a542e06b7d28",
      [111-1] = "fa9121c7b32b9e01733d034cfc78cbf67f926c7ed83e82200ef86818196921760b4beff48404df811b953828274461673c68d04e297b0eb7b2b4d60fc6b566a2",
      [112-1] = "c01d080efd492776a1c43bd23dd99d0a2e626d481e16782e75d54c2503b5dc32bd05f0f1ba33e568b88fd2d970929b719ecbb152f58f130a407c8830604b70ca",
      [113-1] = "55ddd8ac210a6e18ba1ee055af84c966e0dbff091c43580ae1be703bdb85da31acf6948cf5bd90c55a20e5450f22fb89bd8d0085e39f85a86cc46abbca75e24d",
      [114-1] = "5e9eb0e4b270d086e77eeaf3ce8b1cfc615031b8c463dc34f5c139786f274f22accb4d89e8f40d1a0c2acc84c4dc0f2bab390a9d9495493bd617ed004271bb64",
      [115-1] = "eaa30f93760743ac7d0a6cb8ed5ef3b30c59097bc44d0ec337344301deba9fb92b20c488d55de415f6aaed0df4925b42894b81d2e1cde89d91ec7f6cc67262b4",
      [116-1] = "a8bff469314a1ce0c990bb3fd539d92accb6249cc674b559bc9d3898b7a126fee597197fa42c971443470053c7d7f54b09371a59b0f7af87b1917c5347e8f8e0",
      [117-1] = "c0c27aea8dbe169c4cf25176cbf12db708fd6303db8cf94a1cfb402c1680d3d68f39bc5b9a10970dd5373cb0fe1cb36fa50e33165140d72933ba87af9d5d1ffe",
      [118-1] = "d6f856c92a5a694dec299f5a4765bed80e4e7431aa5505f82b21584dd1f1fe970f698bec5a3f4faa593d1aac944a96c21b85463a773cdf3ad87c4a00fb9e5073",
      [119-1] = "130396a75cb483f2eee8c56d8a668bb3d2641f5243212c0bee2bd33da096ad9eb8179fe18f9eaacf76e09fae9de4c3f14ba13341e345be05bf76c182cc3468cb",
      [120-1] = "f241de612b01aa2fa3cf01531d2a8e5e17fc761dfd48a704a834a47f57d6eade7804ecc39be42fdef16ec6adeaf7c01c2fd0c4cc97d3860907cfa4a3b36d0c05",
      [121-1] = "0ae7a79758a9ffbd1c04aa080bfa82daf9641f9c2a1cc82b628cbe4006bd47701c78e5022d2ca5ca5384d26d93fb16d595b9775dab17c88ef38e4ce9fdac4b52",
      [122-1] = "139de16e90ad012e39f72279140f4f6b12bb93f1cbcffbd1b132f39e7f92822d2b56beafc9ed83a0bf59c5525ffd125b83294b65f51f6e8ebbf85eb1aba85b87",
      [123-1] = "ccd869ee70892a0f5f3c269b9e21ffc99703855c1c652774febbaf1311bd58c80fb66bc3f747dd98b2f11ad9f5d8311b7ca706d456fc82ccd46bfb01f19e8d87",
      [124-1] = "77469b56910b022f45f509dcfca04494d8e7978073debf96398cb5a86f31bbe55f2a807a3271b8fe124171416917ab01a87acc7bf005977caaf7b484d87d6a93",
      [125-1] = "577a80f7cb393ac140af066b524166bb02a8059980b65fd100ecdcbec7721d2d0519a151ae730d4b6d9b97a8e5d2415aa8157856aeae4a7444171ef2a9db252b",
      [126-1] = "9986e67bf52a755f8924f28dae9627f889a45d466ce8616c4ed68ec3afd7a3a14785c335c6c68d62e7379af762b2bc17117a902083a99fae337a268a5d4f4427",
      [127-1] = "828613968b501dc00a97e08c73b118aa8876c26b8aac93df128502ab360f91bab50a51e088769a5c1eff4782ace147dce3642554199876374291f5d921629502",
      [128-1] = "b73d1929aa615934e61a871596b3f3b33359f42b8175602e89f7e06e5f658a243667807ed300314b95cacdd579f3e33abdfbe351909519a846d465c59582f321",
      [129-1] = "4f681e0bd53cda4b5a2041cc8a06f2eabde44fb16c951fbd5b87702f07aeab611565b19c47fde30587177ebb852e3971bbd8d3fd30da18d71037dfbd98420429",
      [130-1] = "b2fc6acdce83feb0b9439433915fe5dc1c73af6f17e962d7badd7ad5dd7c5032bc1744855d0ba09da5e4ab1bb1caca3aad8e4a947faa19c4769e128bacfe6b85",
      [131-1] = "da776a6dc98efb67553dd7867916c5782feba6e8961c878a28cc77fa99620e8417d8ca97941ae9d22bb2949c962221de98e90a18437eaeab66d00eba55d92df9",
      [132-1] = "d3af4d87de1febdf1b0fdf9012de0788109c2b692a59a3571bddc35b859d7d6cf5aa8aa66f1834a24d3ffed0705aa3e653a978eeb0289f8bab9e5a1aa3533121",
      [133-1] = "5a3c0664bc599be7686301de9d200c927eef12cb0daace1a8b540b63e3d7e0a1591aac7f87699b31bb1af24410d7ab18d0b258bc399256c25e213466e6d18420",
      [134-1] = "dd5ff1c06a5c050e778a691568814b4db5f09682b40636ea9e13c0552a513e49241934f1027b774b81e8aba4cced4f55c2124eb1dccae7e5c9fb09d9c7206a3e",
      [135-1] = "018305457c1804285649e77d1ada038a4db3b166a39dc93504584bbb9f95be2d5a2147798aa71d0f240f442d2daf4928695548cf828c7fe314149544b442fb7c",
      [136-1] = "389860167dc973108096b0c37276b4d62dd707c9826651318ad560af1daf234376f49e95419d310e9c5095d439f6d16e978e848d1951b1586dec6e0aaa84e61c",
      [137-1] = "1d91d9f1934334408937ab161416f6276975c50cc980c6fdd332496c5c0ec29f62baac0b2c0acbf8e57336acf93c1e3172eb6c627a02679b419a90acc7c8a65f",
      [138-1] = "a93449912b83c925b3b66af530994a565164870d4d1c779c97392d6438337d5807e5f366ce4ba5e9ea16ceb490b8bb3eb001bf4f513a463e0f01e56e2ff8a3ed",
      [139-1] = "884040104d933d47e61bff06f458db489f43a823baa14f3e54bc04e9a8edbb38c36a1e81f122a9dd727efcfa9f9dcb70f765c9b70f215e6b63103b4ef830444c",
      [140-1] = "bb1d3fa26d5432447589030b9fb510b306120ec3e50752c4c298e3ab8952523826e10f48344a10dc07e67718c0746032217ad982acc6c4f2b120f529142dcbf7",
    })
      Assert(sha512(RepeatStr("a", i+1)) = dgst)
    Next

    ; -- negative byte values
    DebugPrint("  Negative byte values...")
    Assert(sha512(RepeatStr("\255",1e3)) = "4f598854fd3db77c067dfc877450c56f326c03be82384833e01824c4b3187ac38b73fc41d6bd78e9fa8793d6106a1dc1705afb4250d2fa4508ca7b102bdb62d2")
  
  EndFunction

  Local Function test_md5()
    DebugPrint("=== MD5 ===")
    Local md5 = sha.md5
    DebugPrint("  Performing tests...")
    Assert(md5("") = "d41d8cd98f00b204e9800998ecf8427e")
    Assert(md5("a") = "0cc175b9c0f1b6a831c399e269772661")
    Assert(md5("abc") = "900150983cd24fb0d6963f7d28e17f72")
    Assert(md5("message digest") = "f96b697d7cb7938d525a2f31aaf161d0")
    Assert(md5("abcdefghijklmnopqrstuvwxyz") = "c3fcd3d76192e4007dfb496cca67e13b")
    Assert(md5("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq") = "8215ef0796a20bcaaae116d3876c664a")
    Assert(md5("The quick brown fox jumps over the lazy dog") = "9e107d9d372bb6826bd81d3542a419d6")
    Assert(md5("The quick brown fox jumps over the lazy dog.") = "e4d909c290d0fb1ca068ffaddf22cbd0")
    Assert(md5("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") = "d174ab98d277d9f5a5611c2c9f419d9f")
    Assert(md5(RepeatStr("1234567890", 8)) = "57edf4a22be3c955ac49da2e2107b67a")
    Assert(md5(RepeatStr("\255", 54)) = "30855eb73c2f88ffc3005b998ca4cd69")
    Assert(md5(RepeatStr("\255", 55)) = "fd696aa639acaba9ce0e0964028fbe81")
    Assert(md5(RepeatStr("\255", 56)) = "74444b7e7b01632f3277365c8ca35ec2")

  EndFunction
  
  Local Function test_sha1()
    Local sha1 = sha.sha1
    DebugPrint("=== SHA1 ===")
    Assert(sha1("") = "da39a3ee5e6b4b0d3255bfef95601890afd80709")
    Assert(sha1("abc") = "a9993e364706816aba3e25717850c26c9cd0d89d")
    Assert(sha1("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq") = "84983e441c3bd26ebaae4aa1f95129e5e54670f1")
    Assert(sha1("The quick brown fox jumps over the lazy dog") = "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12")
    Assert(sha1("The quick brown fox jumps over the lazy cog") = "de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3")
  EndFunction


  Local Function test_sha3()
    DebugPrint("=== SHA3 ===")
    DebugPrint("  Performing tests...")
    Assert(sha.sha3_224("") = "6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7")
    Assert(sha.sha3_256("") = "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a")
    Assert(sha.sha3_384("") = "0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004")
    Assert(sha.sha3_512("") = "a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26")
    Assert(sha.sha3_384("ciccuzzo") = "e2f96db19fab742a6ca22fcefc79edcbb75c8208f33c9c6ed97675e1042625d86b2d2c574950278b0f35809875be8ab9")

    Assert(sha.sha3_224("The quick brown fox jumps over the lazy dog") = "d15dadceaa4d5d7bb3b48f446421d542e08ad8887305e28d58335795")
    Assert(sha.sha3_256("The quick brown fox jumps over the lazy dog") = "69070dda01975c8c120c3aada1b282394e7f032fa9cf32f4cb2259a0897dfc04")
    Assert(sha.sha3_384("The quick brown fox jumps over the lazy dog") = "7063465e08a93bce31cd89d2e3ca8f602498696e253592ed26f07bf7e703cf328581e1471a7ba7ab119b1a9ebdf8be41")
    Assert(sha.sha3_512("The quick brown fox jumps over the lazy dog") = "01dedd5de4ef14642445ba5f5b97c15e47b9ad931326e4b0727cd94cefc44fff23f07bf543139939b49128caf436dc1bdee54fcb24023a08d9403f9b4bf0d450")
    
    DebugPrint("  Testing shake256...")
    Assert(sha.shake256(64, "") = "46b9dd2b0ba88d13233b3feb743eeb243fcd52ea62b81b82b50c27646ed5762fd75dc4ddd8c0f200cb05019d67b592f6fc821c49479ab48640292eacb3b7c4be")
    Assert(sha.shake256(25, RepeatStr("€", 45)) = "8f571c3d042d43f9072941f81862e34b7127cae59edc8092e7")      ;-- input data is 1 byte less than block size
    Assert(sha.shake256(26, RepeatStr("€", 90)) = "ea57f4ed3404c1a2a3f19d706cbc0971665104b49f8aea5569a2")    ;-- input data is 2 bytes less than two blocks
    Assert(sha.shake256(27, RepeatStr("€", 136))= "8c1fe6c7831770ee3c5738f2ebfddff126e71e798daf26c0735a2f")  ;-- input data is exactly three blocks
    Assert(sha.shake256(150, "The quick brown fox jumps over the lazy dog") = "2f671343d9b2e1604dc9dcf0753e5fe15c7c64a0d283cbbf722d411a0e36f6ca1d01d1369a23539cd80f7c054b6e5daf9c962cad5b8ed5bd11998b40d5734442bed798f6e5c915bd8bb07e0188d0a55c1290074f1c287af06352299184492cbdec9acba737ee292e5adaa445547355e72a03a3bac3aac770fe5d6b66600ff15d37d5b4789994ea2aeb097f550aa5e88e4d8ff0ba07b8")
    
    DebugPrint("  Testing shake128...")
    Assert(sha.shake128(32, "") = "7f9c2ba4e88f827d616045507605853ed73b8093f6efbc88eb1a6eacfa66ef26")
    Assert(sha.shake128(32, "The quick brown fox jumps over the lazy dof") = "853f4538be0db9621a6cea659a06c1107b1f83f02b13d18297bd39d7411cf10c")
    Assert(sha.shake128(32, "The quick brown fox jumps over the lazy dog") = "f4202e3c5852f9182a0430fd8144f0a74b95e7417ecae17db0f8cfeed0e3e66e")
    Assert(sha.shake128(12, "The quick brown fox jumps over the lazy dog") = "f4202e3c5852f9182a0430fd")
    Assert(sha.shake128(11, "The quick brown fox jumps over the lazy dog") = "f4202e3c5852f9182a0430")
    Assert(sha.shake128(0,  "The quick brown fox jumps over the lazy dog") = "")

    ;-- digest_size_in_bytes == (-1) means "generate infinite SHAKE-stream instead of fixed-width digest"
    DebugPrint("  Testing shake-stream...")
    Local get_next_part_of_digest = sha.shake128(-1, "The quick brown fox jumps over the lazy dog")
    Assert(get_next_part_of_digest(5) = "f4202e3c58") ;-- 5 bytes in hexadecimal representation
    Assert(get_next_part_of_digest()  = "52")         ;-- size=1 is assumed when omitted
    Assert(get_next_part_of_digest(0) = "")           ;-- size=0 is a valid size
    Assert(get_next_part_of_digest(4) = "f9182a04")   ;-- and so on to the infinity...

    ; -- take long message (in chunk-by-chunk mode) and generate infinite SHAKE-stream
    DebugPrint("  Testing shake-stream 2...")
    Local append_input_message = sha.shake128(-1)
    append_input_message("The quick brown fox")
    append_input_message(" jumps over")
    append_input_message(" the lazy dog")
    Local get_next_part_of_digest = append_input_message()  ;-- input stream is terminated, now starting to receive the output stream
    Assert(get_next_part_of_digest(5) = "f4202e3c58")       ;-- 5 bytes in hexadecimal representation
    Assert(get_next_part_of_digest(5) = "52f9182a04")       ;-- and so on to the infinity...

  EndFunction
  
Local Function test_hmac()

  DebugPrint("=== HMAC ===")
  Local hmac = sha.hmac
  DebugPrint("  Testing hmac...")
  Assert(hmac(sha.sha1,   "your key", "your message") = "317d0dfd868a5c06c9444ac1328aa3e2bfd29fb2")
  Assert(hmac(sha.sha512, "your key", "your message") = "2f5ddcdbd062a5392f07b0cd0262bf52c21bfb3db513296240cca8d5accc09d18d96be0a94995be4494c032f1eda946ad549fb61ccbe985d160f0b2f9588d34b")
  Assert(hmac(sha.md5,    "", "") = "74e6f7298a9c2d168935f58c001bad88")
  Assert(hmac(sha.sha256, "", "") = "b613679a0814d9ec772f95d778c35fc5ff1697c493715653c6c712144292c5ad")
  Assert(hmac(sha.sha1,   "", "") = "fbdb1d1b18aa6c08324b7d64b71fb76370690e1d")
  Assert(hmac(sha.md5,    "key", "The quick brown fox jumps over the lazy dog") = "80070713463e7749b90c2dc24911e275")
  Assert(hmac(sha.sha256, "key", "The quick brown fox jumps over the lazy dog") = "f7bc83f430538424b13298e6aa6fb143ef4d59a14946175997479dbc2d1a3cd8")
  Assert(hmac(sha.sha1,   "key", "The quick brown fox jumps over the lazy dog") = "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9")
  
  ;-- chunk-by-chunk mode
  DebugPrint("  Testing hmac chunks...")
  Local append = hmac(sha.sha1, "key")
  Append("The quick brown fox")
  Append("")  ; -- empty string is allowed as a valid chunk
  Append(" jumps over the lazy dog")
  Assert(append() = "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9") ; -- invocation without an argument receives the result
  
  DebugPrint("  Testing hmac larger blocks...")
  Local key, message = RepeatStr("\170", 131), "Test Using Larger Than Block-Size Key - Hash Key First"
  Assert(hmac(sha.sha3_224, key, message) = "b4a1f04c00287a9b7f6075b313d279b833bc8f75124352d05fb9995f")
  Assert(hmac(sha.sha3_256, key, message) = "ed73a374b96c005235f948032f09674a58c0ce555cfc1f223b02356560312c3b")
  Assert(hmac(sha.sha3_384, key, message) = "0fc19513bf6bd878037016706a0e57bc528139836b9a42c3d419e498e0e1fb9616fd669138d33a1105e07c72b6953bcc")
  Assert(hmac(sha.sha3_512, key, message) = "00f751a9e50695b090ed6911a4b65524951cdc15a73a5d58bb55215ea2cd839ac79d2b44a39bafab27e83fde9e11f6340b11d991b1b91bf2eee7fc872426c3a4")

  ; assert(not pcall(hmac, function(x) return sha.sha256(x) end, "key", "message"))  -- must raise "unknown hash function" error

  EndFunction
  
Local Function test_base64()
  DebugPrint("=== Test Base64 ===")
  Local bin_to_base64 = sha.bin2base64
  DebugPrint("  Encoding...")
  Assert(bin_to_base64(""      ) = ""        )
  Assert(bin_to_base64("f"     ) = "Zg=="    )
  Assert(bin_to_base64("fo"    ) = "Zm8="    )
  Assert(bin_to_base64("foo"   ) = "Zm9v"    )
  Assert(bin_to_base64("foob"  ) = "Zm9vYg==")
  Assert(bin_to_base64("fooba" ) = "Zm9vYmE=")
  Assert(bin_to_base64("foobar") = "Zm9vYmFy")

  Local base64_to_bin = sha.base642bin
  DebugPrint("  Decoding...")
  Assert(base64_to_bin(""        ) = ""      )
  Assert(base64_to_bin("Zg=="    ) = "f"     )
  Assert(base64_to_bin("Zm8="    ) = "fo"    )
  Assert(base64_to_bin("Zm9v"    ) = "foo"   )
  Assert(base64_to_bin("Zm9vYg==") = "foob"  )
  Assert(base64_to_bin("Zm9vYmE=") = "fooba" )
  Assert(base64_to_bin("Zm9vYmFy") = "foobar")

  EndFunction
  
  DebugPrint("+---------------------------------+")
  DebugPrint("| TESTING...                      |")
  DebugPrint("+---------------------------------+")
  
  StartTimer(1)
  
  Assert(sha.sha224("abc") = "23097d223405d8228642a477bda255b32aadbce4bda0b3f7e36c9da7")
  Assert(sha.sha224("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq") = "75388b16512776cc5dba5da1fd890150b0c6455cb4f58b1952522525")
  
  Assert(sha.sha384("abc") = "cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7")
  Assert(sha.sha384("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu") = "09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712fcc7c71a557e2db966c3e9fa91746039")

  Assert(sha.sha512_224("abc") = "4634270f707b6a54daae7530460842e20e37ed265ceee9a43e8924aa")
  Assert(sha.sha512_224("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu") = "23fec5bb94d60b23308192640b0c453335d664734fe40e7268674af9")

  Assert(sha.sha512_256("abc") = "53048e2681941ef99b2e29b76b4c7dabe4c2d0c634fc6d46e0e2f13107e7af23")
  Assert(sha.sha512_256("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu") = "3928e184fb8690f840da3988121d31be65cb9d3ef83ee6146feac861e19b563a")
  
  test_sha256()
  test_sha512()
  test_md5()
  test_sha1()
  test_sha3()
  test_hmac()
  test_base64()
   
  DebugPrint("Elapsed: ", GetTimer(1) .. "ms")
  DebugPrint("\n\n*** ALL TESTS PASSED ***")
  DebugPrompt("\nHIT ENTER TO END")
EndFunction

/* ELAPSED
   Con controllo 32bit
   -  96990ms
   -   3140ms usando Cast()    -> Su ARM non funziona
   -  61575ms usando if multiplo
   -  11920ms usando loop matematico (senza cache 36659ms)
   - Usando da 51 a 32 bit
   -   7517ms
   -   5160ms senza linehook
   -   4059ms come sopra ma con un controllo aggiuntivo
   -   On ARM (Pi 4) : 91372ms
   Senza controllo
   -   2744ms
*/

/* TEST
@DISPLAY { Hidden = True }
@OPTIONS { EnableDebug = True }
test_hash_lib()
*/
